<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utilities.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utilities.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const fs = require('fs').promises;
const path = require('path');
const os = require('os');
const { v4: uuidv4 } = require('uuid'); // Import uuid for unique directory names
const logger = require('./logger'); // Assuming you have a logger utility

/**
 * Creates a unique temporary directory.
 * @returns {Promise&lt;string>} A promise that resolves with the path to the 
 * created temporary directory.
 */
const createUniqueTempDir = async () => {
  const tempDir = os.tmpdir();
  const uniqueDirName = `genai-temp-${uuidv4()}`;
  const newDirPath = path.join(tempDir, uniqueDirName);

  try {
    await fs.mkdir(newDirPath, { recursive: true });
    logger.debug(`Created unique temporary directory: ${newDirPath}`);
    return newDirPath;
  } catch (error) {
    logger.error(
      `Error creating unique temporary directory: ${error.message}`,
    );
    throw new Error(
      `Failed to create unique temporary directory: ${error.message}`,
    );
  }
};

/**
 * Recursively deletes a directory.
 * @param {string} dirPath The path to the directory to delete.
 * @returns {Promise&lt;void>} A promise that resolves when the directory is deleted.
 */
const deleteDirectoryRecursively = async (dirPath) => {
  try {
    await fs.rm(dirPath, { recursive: true, force: true });
    logger.debug(`Deleted directory recursively: ${dirPath}`);
  } catch (error) {
    logger.error(
      `Error deleting directory recursively ${dirPath}: ${error.message}`,
    );
    // Depending on requirements, you might want to throw here or just log
    // For temporary directories, logging might be sufficient as cleanup is best effort.
  }
};

/**
 * Reads all files in a directory and its subdirectories.
 * @async
 * @param {string} dir The directory to start reading from.
 * @returns {Promise&lt;Map&lt;string, string>>} A promise that resolves to a Map where keys are
 * relative file paths and values are file contents.
 */
/* eslint-disable no-restricted-syntax, no-await-in-loop */
const readFilesInDirectory = async (dir) => {
  const files = new Map();
  try {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        // Recursively read subdirectories
        const subDirFiles = await readFilesInDirectory(fullPath);
        // Merge maps
        for (const [relativePath, content] of subDirFiles.entries()) {
          files.set(path.join(entry.name, relativePath), content);
        }
      } else if (entry.isFile()) {
        // Read file content
        const content = await fs.readFile(fullPath, 'utf8');
        files.set(entry.name, content); // Store with just the filename for now
      }
    }
  } catch (error) {
    logger.error(`Error reading directory ${dir}: ${error.message}`);
    throw new Error(`Failed to read directory contents: ${error.message}`);
  }
  return files;
};
/* eslint-enable no-restricted-syntax, no-await-in-loop */

/**
 * Saves code content to a local file, creating directories if needed.
 * Handles cases where filename includes a path.
 * @async
 * @param {string} code The code content to save.
 * @param {string} filename The desired filename, can include a relative path.
 * @param {string} [directory='/tmp/nodeapp/'] The base directory to save the file
 *  in if filename is relative.
 * @returns {Promise&lt;string>} A promise that resolves with the full path to the 
 * saved file.
 * @throws {Error} If saving the file fails.
 */
const saveCodeToFile = async (code, filename, directory = '/tmp/nodeapp/') => {
  // Determine the full file path
  let fullPath;
  if (path.isAbsolute(filename) || filename.includes(path.sep)) {
    // If filename is already an absolute path or contains path separators, use it directly
    fullPath = filename;
  } else {
    // Otherwise, join the directory and filename
    fullPath = path.join(directory, filename);
  }

  // Ensure the directory exists
  const dirPath = path.dirname(fullPath);
  try {
    await fs.mkdir(dirPath, { recursive: true });
    logger.debug(`Ensured directory exists: ${dirPath}`);
  } catch (error) {
    logger.error(`Error creating directory ${dirPath}: ${error.message}`);
    throw new Error(`Failed to create directory for file: ${error.message}`);
  }

  // Save the file
  try {
    await fs.writeFile(fullPath, code, 'utf8');
    logger.info(`Code saved successfully to: ${fullPath}`);
    return fullPath;
  } catch (error) {
    logger.error(`Error saving file ${fullPath}: ${error.message}`);
    throw new Error(`Failed to save file: ${error.message}`);
  }
};

module.exports = {
  createUniqueTempDir,
  deleteDirectoryRecursively,
  readFilesInDirectory,
  saveCodeToFile,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addResponse">addResponse</a></li><li><a href="global.html#availableFunctionsRegistry">availableFunctionsRegistry</a></li><li><a href="global.html#callFunctionByName">callFunctionByName</a></li><li><a href="global.html#checkBranchExists">checkBranchExists</a></li><li><a href="global.html#checkRepoExists">checkRepoExists</a></li><li><a href="global.html#cleanupSession">cleanupSession</a></li><li><a href="global.html#codeReviews">codeReviews</a></li><li><a href="global.html#commitFiles">commitFiles</a></li><li><a href="global.html#createBranch">createBranch</a></li><li><a href="global.html#createGithubPullRequest">createGithubPullRequest</a></li><li><a href="global.html#createRepo">createRepo</a></li><li><a href="global.html#createUniqueTempDir">createUniqueTempDir</a></li><li><a href="global.html#deleteDirectoryRecursively">deleteDirectoryRecursively</a></li><li><a href="global.html#downloadFile">downloadFile</a></li><li><a href="global.html#downloadMutexes">downloadMutexes</a></li><li><a href="global.html#fetchRepoContentsRecursive">fetchRepoContentsRecursive</a></li><li><a href="global.html#funcsMetadata">funcsMetadata</a></li><li><a href="global.html#generateGoogleMapsLink">generateGoogleMapsLink</a></li><li><a href="global.html#getAuthToken">getAuthToken</a></li><li><a href="global.html#getAvailableFunctions">getAvailableFunctions</a></li><li><a href="global.html#getChatResponse">getChatResponse</a></li><li><a href="global.html#getDownloadMutex">getDownloadMutex</a></li><li><a href="global.html#getFunctionDefinitionsForTool">getFunctionDefinitionsForTool</a></li><li><a href="global.html#getKey">getKey</a></li><li><a href="global.html#getResponse">getResponse</a></li><li><a href="global.html#getSessionFuncsMetadata">getSessionFuncsMetadata</a></li><li><a href="global.html#getSessionFunctionRegistry">getSessionFunctionRegistry</a></li><li><a href="global.html#getSessionMutex">getSessionMutex</a></li><li><a href="global.html#getSessionTokenMutex">getSessionTokenMutex</a></li><li><a href="global.html#getVehicleHistory">getVehicleHistory</a></li><li><a href="global.html#handleGitHubApiError">handleGitHubApiError</a></li><li><a href="global.html#handleNotFoundError">handleNotFoundError</a></li><li><a href="global.html#listBranches">listBranches</a></li><li><a href="global.html#listCommitHistory">listCommitHistory</a></li><li><a href="global.html#listDirectoryContents">listDirectoryContents</a></li><li><a href="global.html#listGitHubActions">listGitHubActions</a></li><li><a href="global.html#listPublicRepos">listPublicRepos</a></li><li><a href="global.html#loadMappingFunctions">loadMappingFunctions</a></li><li><a href="global.html#planRoute">planRoute</a></li><li><a href="global.html#readContext">readContext</a></li><li><a href="global.html#registerFunction">registerFunction</a></li><li><a href="global.html#registryMutex">registryMutex</a></li><li><a href="global.html#saveCodeToFile">saveCodeToFile</a></li><li><a href="global.html#sessionAuthTokens">sessionAuthTokens</a></li><li><a href="global.html#sessionTokenExpiries">sessionTokenExpiries</a></li><li><a href="global.html#sessionTokenMutexes">sessionTokenMutexes</a></li><li><a href="global.html#sessions">sessions</a></li><li><a href="global.html#switchBranch">switchBranch</a></li><li><a href="global.html#walkDir">walkDir</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Mon May 12 2025 01:14:27 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
