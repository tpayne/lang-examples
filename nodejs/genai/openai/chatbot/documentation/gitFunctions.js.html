<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: gitFunctions.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: gitFunctions.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const path = require('path');
const fs = require('fs').promises;
const util = require('util');
const { Mutex } = require('async-mutex'); // Import Mutex for thread safety

const GITHUB_API_VERSION = '2022-11-28';
const USER_AGENT = 'AIBot';
const githubToken = process.env.GITHUB_TOKEN;
const superagent = require('superagent');
const logger = require('./logger');

const {
  mkdir,
} = require('./utilities');

/**
 * Manages mutexes for download URLs per session to prevent concurrent downloads of the same file.
 * @type {Map&lt;string, Map&lt;string, Mutex>>}
 */
const downloadMutexes = new Map();

/**
 * Handles "Not Found" errors from the GitHub API.
 * If the error message indicates "Not Found", it throws a more
 * user-friendly error suggesting the user reword their request.
 * Otherwise, it re-throws the original error.
 * @param {Error} error The error object caught from the API call.
 * @param {string} [context=''] Optional context for the error message.
 * @throws {Error} Modified error for "Not Found" or the original.
 */
function handleNotFoundError(error, context = '') {
  if (error.message === 'Not Found') {
    throw new Error(`${error} ${context}: Please reword the request as it was not understood`);
  }
  throw error;
}

/**
 * Logs and throws a custom error for GitHub API responses that
 * indicate an error status. Includes status, text, and body message.
 * @param {object} response The SuperAgent response object.
 * @param {string} [context=''] Optional context for the error message.
 * @throws {Error} Custom error detailing the GitHub API error.
 */
async function handleGitHubApiError(response, context = '') {
  logger.error(
    `GitHub API Error ${context} (status):`,
    response.status,
    response.statusText,
    response.body,
  );
  let errorMessage = `GitHub API Error ${context}: ${response.status} - ${response.statusText}`;
  if (response.body &amp;&amp; response.body.message) {
    errorMessage += ` - ${response.body.message}`;
  }
  throw new Error(errorMessage);
}

/**
 * Gets or creates a mutex for a specific download URL within a session.
 * @param {string} sessionId The unique identifier for the session.
 * @param {string} downloadUrl The URL of the file being downloaded.
 * @returns {Mutex} The mutex for the download URL in the session.
 */
function getDownloadMutex(sessionId, downloadUrl) {
  if (!downloadMutexes.has(sessionId)) {
    downloadMutexes.set(sessionId, new Map());
  }
  const sessionMutexes = downloadMutexes.get(sessionId);
  if (!sessionMutexes.has(downloadUrl)) {
    sessionMutexes.set(downloadUrl, new Mutex());
  }
  return sessionMutexes.get(downloadUrl);
}

/**
 * Helper function to download a file from a URL using Superagent, specific to a session.
 * @param {string} sessionId The unique identifier for the session.
 * @param {string} url - The URL to download from.
 * @param {string} localFilePath - The local path to save the file.
 * @param {string|null} [token=null] - Optional GitHub token.
 */
async function downloadFile(sessionId, url, localFilePath, token = null) {
  // Basic rate limiting per session to avoid concurrent downloads of the same URL
  const downloadMutex = getDownloadMutex(sessionId, url);
  const release = await downloadMutex.acquire();
  try {
    const request = superagent.get(url);
    request.set('User-Agent', USER_AGENT);
    if (token) {
      request.set('Authorization', `token ${token}`);
    }

    request.buffer(true);
    request.parse(superagent.parse['application/octet-stream']);

    const response = await request;

    if (response.status !== 200) {
      throw new Error(`Error downloading ${url}: HTTP ${response.status} - ${response.text}`);
    }

    if (Buffer.isBuffer(response.body)) {
      await fs.writeFile(localFilePath, response.body);
    } else {
      throw new Error(`Error downloading ${url}: Expected Buffer, received ${typeof response.body}`);
    }
  } catch (error) {
    logger.error('Error downloading (exception):', url, localFilePath, error.message || error, `[Session: ${sessionId}]`);
    handleNotFoundError(error, ` for downloading ${url}`);
    throw error; // Re-throw the error for the caller to handle
  } finally {
    release();
  }
}

/**
 * Recursively fetches files and directories from a GitHub repository for a specific session.
 *
 * @param {string} sessionId The unique identifier for the session.
 * @param {string} username - The owner of the repository.
 * @param {string} repoName - The name of the repository.
 * @param {string} repoPath - The starting path within the repository.
 * @param {string} localDestPath - The local directory path where content should be saved.
 * @param {boolean} [includeDotGithub=true] - Whether to include the .github directory.
 * @param {number} [retryCount=0] - Internal retry counter.
 * @param {number} [maxRetries=3] - Maximum number of retries for API requests.
 */
async function fetchRepoContentsRecursive(
  sessionId,
  username,
  repoName,
  repoPath,
  localDestPath,
  includeDotGithub = true,
  retryCount = 0,
  maxRetries = 3,
) {
  const apiUrl = `https://api.github.com/repos/${username}/${repoName}/contents/${repoPath}`;

  if (!localDestPath || localDestPath === '.'
    || localDestPath === `./${repoName}`
    || localDestPath === repoName) {
    return { success: false, message: 'Error: You need to specify a download directory' };
  }

  try {
    await mkdir(localDestPath);

    const request = superagent.get(apiUrl);
    request.set('Accept', 'application/vnd.github.v3+json');
    request.set('User-Agent', USER_AGENT);
    if (githubToken) {
      request.set('Authorization', `token ${githubToken}`);
    }

    const response = await request;
    /* eslint-disable max-len, no-promise-executor-return,
             no-restricted-syntax,
             no-await-in-loop,
             no-continue */

    if (response.status === 403 &amp;&amp; response.headers['x-ratelimit-remaining'] === '0' &amp;&amp; retryCount &lt; maxRetries) {
      const resetTime = parseInt(response.headers['x-ratelimit-reset'], 10) * 1000;
      const waitTime = resetTime - Date.now() + 1000; // Add a small buffer
      logger.warn(`Rate limit hit for session ${sessionId}. Retrying in ${waitTime / 1000} seconds (Attempt ${retryCount + 1}/${maxRetries}).`);
      await new Promise((resolve) => setTimeout(resolve, waitTime));
      return fetchRepoContentsRecursive(
        sessionId,
        username,
        repoName,
        repoPath,
        localDestPath,
        includeDotGithub,
        retryCount + 1,
        maxRetries,
      );
    }

    if (response.status !== 200) {
      logger.error(`GitHub API error for path "${repoPath}" [Session: ${sessionId}]: HTTP ${response.status} - ${response.text}`);
      handleNotFoundError(response, ` for repository ${username}/${repoName} at path "${repoPath}"`);
      return { success: false, message: `GitHub API error: HTTP ${response.status} for ${apiUrl}` };
    }

    /** @type {GitHubItem|GitHubItem[]} */
    const items = response.body;

    if (!Array.isArray(items)) {
      logger.warn(`Expected an array of items from API for path "${repoPath}", but received: ${typeof items} [Session: ${sessionId}]`);
      if (items &amp;&amp; items.type === 'file' &amp;&amp; items.download_url) {
        const filePath = path.join(localDestPath, items.name);
        try {
          await downloadFile(sessionId, items.download_url, filePath, githubToken);
        } catch (error) {
          return { success: false, message: `Error downloading single file: ${error.message}` };
        }
      }
      return { success: true, message: `Processed single item at path "${repoPath}"` };
    }

    for (const item of items) {
      const currentRepoPath = item.path;
      const currentLocalPath = path.join(localDestPath, item.name);

      if (!includeDotGithub &amp;&amp; (item.name === '.github' || currentRepoPath.startsWith('.github/'))) {
        continue;
      }

      if (item.type === 'file') {
        if (item.download_url) {
          try {
            await downloadFile(sessionId, item.download_url, currentLocalPath, githubToken);
          } catch (error) {
            return { success: false, message: `Error downloading file "${item.name}": ${error.message}` };
          }
        }
      } else if (item.type === 'dir') {
        const result = await fetchRepoContentsRecursive(
          sessionId,
          username,
          repoName,
          item.path,
          currentLocalPath,
          includeDotGithub,
          0, // Reset retry count for new recursive calls
          maxRetries,
        );
        if (!result.success) {
          return result; // Propagate failure from subdirectory
        }
      } else if (item.type === 'symlink') {
        logger.warn(`Skipping symlink: ${item.name} (content not fetched) [Session: ${sessionId}]`);
      } else if (item.type === 'submodule') {
        logger.warn(`Skipping submodule: ${item.name} (content not fetched) [Session: ${sessionId}]`);
      } else {
        logger.warn(`Unknown item type "${item.type}" for item: ${item.name} [Session: ${sessionId}]`);
      }
    }
    return {
      success: true,
      message:
        `Successfully processed directory "${repoPath}"`,
    };
    /* eslint-enable max-len, no-promise-executor-return, no-restricted-syntax, no-await-in-loop, no-continue */
  } catch (error) {
    logger.debug(`Error object is ${util.inspect(error, { depth: null })} [Session: ${sessionId}]`);
    logger.error('Error in fetchRepoContentsRecursive (exception):', repoPath, error.message || error, `[Session: ${sessionId}]`);
    if (error.response) {
      logger.error(`Error downloading files (exception): ${error.response.text} [Session: ${sessionId}]`);
      if (error.response.status === 404) {
        throw new Error('Not Found: Check repo and directory names.');
      }
      if (error.response.body &amp;&amp; error.response.body.errors
        &amp;&amp; error.response.body.errors.length > 0) {
        throw new Error(error.response.body.errors[0].message);
      }
      throw new Error(error.response.body.message || 'Failed to download repo');
    } else {
      throw error;
    }
  }
}

/* eslint-disable no-restricted-syntax, no-await-in-loop, consistent-return */
/**
 * Lists the names of public repositories for a given GitHub username.
 * Fetches repo data and extracts the 'name' property.
 * Handles API errors and "Not Found" exceptions.
 * @async
 * @param {string} username The GitHub username.
 * @returns {Promise&lt;string[]>} Array of public repository names.
 * @throws {Error} If API request fails or user is not found.
 */
async function listPublicRepos(username) {
  const url = `https://api.github.com/users/${username}/repos`;
  try {
    const response = await superagent
      .get(url)
      .set('Authorization', `Bearer ${githubToken}`)
      .set('Accept', 'application/json')
      .set('User-Agent', USER_AGENT);

    if (response.status === 200) {
      return response.body.map((repo) => repo.name);
    }
    await handleGitHubApiError(response, `listing repos for user "${username}"`);
  } catch (error) {
    logger.error('Error listing repos (exception):', username, error);
    handleNotFoundError(error, ` for user "${username}"`);
  }
}

/**
 * Lists the names of branches for a given GitHub repository.
 * Fetches branch data and extracts the 'name' property.
 * Handles API errors and "Not Found" exceptions.
 * @async
 * @param {string} username The GitHub username.
 * @param {string} repoName The name of the repository.
 * @returns {Promise&lt;string[]>} Array of branch names.
 * @throws {Error} If API request fails or repository is not found.
 */
async function listBranches(username, repoName) {
  const url = `https://api.github.com/repos/${username}/${repoName}/branches`;
  try {
    const response = await superagent
      .get(url)
      .set('Authorization', `Bearer ${githubToken}`)
      .set('Accept', 'application/json')
      .set('User-Agent', USER_AGENT);

    if (response.status === 200) {
      return response.body.map((branch) => branch.name);
    }
    await handleGitHubApiError(response, `listing branches for ${username}/${repoName}"`);
  } catch (error) {
    logger.error('Error listing branches (exception):', username, repoName, error);
    handleNotFoundError(error, ` for repository ${username}/${repoName}"`);
  }
}

/* eslint-disable no-restricted-syntax, no-await-in-loop, consistent-return */
/**
 * Lists commit history for a specific file or directory in a
 * given GitHub repository.
 * First, verifies that the file or directory exists by
 * querying the repository contents API.
 * If the path exists, it fetches commit data and extracts SHA,
 * message, author, and date.
 * Handles API errors and "Not Found" exceptions.
 *
 * @async
 * @param {string} username The GitHub username.
 * @param {string} repoName The name of the repository.
 * @param {string} dirName The path to the file or directory within the repository.
 * @returns {Promise&lt;Array&lt;{ sha: string, message: string, author: string, date: string }>>}
 * Array of commit history objects.
 * @throws {Error} If API requests fail or file/directory not found.
 */
async function listCommitHistory(username, repoName, dirName) {
  // Pre-validate that the file or directory exists using the GitHub contents API.
  const contentsUrl = `https://api.github.com/repos/${username}/${repoName}/contents/${encodeURIComponent(dirName)}`;

  try {
    await superagent
      .get(contentsUrl)
      .set('Authorization', `Bearer ${githubToken}`)
      .set('Accept', 'application/vnd.github.v3+json')
      .set('User-Agent', USER_AGENT);
  } catch (contentsError) {
    // Log and re-throw as a more specific error.
    logger.error('Error fetching path contents (exception):', username, repoName, dirName, contentsError);
    throw new Error(`The path "${dirName}" in "${username}/${repoName}" does not exist.`);
  }

  // Now that the path exists, construct the commits URL with the path filter.
  const commitsUrl = `https://api.github.com/repos/${username}/${repoName}/commits?path=${encodeURIComponent(dirName)}`;

  try {
    const commitResponse = await superagent
      .get(commitsUrl)
      .set('Authorization', `Bearer ${githubToken}`)
      .set('Accept', 'application/json')
      .set('User-Agent', USER_AGENT);

    if (commitResponse.status === 200) {
      return commitResponse.body.map((commit) => ({
        sha: commit.sha,
        message: commit.commit.message,
        author: commit.commit.author.name,
        date: commit.commit.author.date,
      }));
    }

    // If the commit status isn't 200, use the helper to handle specific API error info.
    await handleGitHubApiError(commitResponse, `listing commit history for "${dirName}" in "${username}/${repoName}"`);
  } catch (error) {
    logger.error('Error listing commit history (exception):', username, repoName, dirName, error);
    handleNotFoundError(error, ` for path "${dirName}" in "${username}/${repoName}"`);
  }
}

/**
 * Lists the contents of a directory (or root if no path) in a GitHub repo.
 * Fetches content data and extracts name, type ('file'/'dir'), and path.
 * Handles API errors and "Not Found" exceptions.
 * @async
 * @param {string} username The GitHub username.
 * @param {string} repoName The name of the repository.
 * @param {string} [repoDirName=''] Optional path to the directory.
 * @param {boolean} [recursive=true] Optional recursive scan.
 *
 * @returns {Promise&lt;Array&lt;{ name: string, type: string, path: string }>>}
 * Array of directory content objects.
 * @throws {Error} If API request fails or repository/path not found.
 */
async function listDirectoryContents(username, repoName, repoDirName = '', recursive = true) {
  const url = `https://api.github.com/repos/${username}/${repoName}/contents/${repoDirName}`;
  try {
    const response = await superagent
      .get(url)
      .set('Authorization', `Bearer ${githubToken}`)
      .set('Accept', 'application/json')
      .set('User-Agent', USER_AGENT);

    const contents = response.body;
    const results = [];

    if (contents.length === 0) {
      return { success: false, message: 'There were no files found in the repo', status: 204 };
    }

    if (!recursive) {
      return response.body.map((item) => ({
        name: item.name,
        type: item.type, // "file" or "dir"
        path: item.path,
      }));
    }

    for (const item of contents) {
      if (item.type === 'file') {
        results.push({
          name: item.name,
          type: 'file',
          path: item.path,
        });
      } else if (item.type === 'dir') {
        // Recursively call for subdirectories
        const subDirContents = await listDirectoryContents(
          username,
          repoName,
          item.path,
          recursive,
        );
        results.push({
          name: item.name,
          type: 'dir',
          path: item.path,
        }, ...subDirContents); // concat the arrays
      } else {
        results.push({
          name: item.name,
          type: item.type,
          path: item.path,
        });
      }
    }
    return results;
  } catch (error) {
    logger.error(`Error listing directories (exception): ${username}/${repoName} `
      + `${repoDirName} - ${error.message}`);
    handleNotFoundError(error, ` for path "${repoDirName}" in "${username}/${repoName}"`);
  }
}

/**
 * Creates a pull request on a given GitHub repository.
 * Sends a POST request to the GitHub API.
 * Handles API errors, including specific GitHub errors.
 * @async
 * @param {string} username The GitHub username.
 * @param {string} repoName The name of the repository.
 * @param {string} title The title of the pull request.
 * @param {string} sourceBranch The branch to merge from.
 * @param {string} targetBranch The branch to merge into.
 * @param {string} [body=''] Optional body of the pull request.
 * @returns {Promise&lt;object>} GitHub API response for the created PR.
 * @throws {Error} If API request fails, repo/branches not found, or validation errors.
 */
async function createGithubPullRequest(
  username,
  repoName,
  title,
  sourceBranch,
  targetBranch,
  body = '',
) {
  const url = `https://api.github.com/repos/${username}/${repoName}/pulls`;
  const postData = {
    title, head: sourceBranch, base: targetBranch, body,
  };

  try {
    const response = await superagent
      .post(url)
      .set('Authorization', `token ${githubToken}`)
      .set('Accept', 'application/vnd.github+json')
      .set('User-Agent', USER_AGENT)
      .set('X-GitHub-Api-Version', GITHUB_API_VERSION)
      .send(postData);

    if ([200, 201].includes(response.status)) {
      return response.body;
    }
    await handleGitHubApiError(response, `creating pull request for ${username}/${repoName}"`);
  } catch (error) {
    logger.error(`Error creating pull request (exception):, ${error.message}`);
    if (error.response) {
      logger.error(`Error creating pull request (exception): ${error.response.text}`);
      if (error.response.status === 404) {
        throw new Error('Not Found: Check repo and branch names.');
      }
      if (error.response.body &amp;&amp; error.response.body.errors
        &amp;&amp; error.response.body.errors.length > 0) {
        throw new Error(error.response.body.errors[0].message);
      }
      throw new Error(error.response.body.message || 'Failed to create PR');
    } else {
      throw error;
    }
  }
}

/**
 * Lists running or queued GitHub Actions workflows and their jobs.
 * Fetches workflow runs by status, then fetches jobs for each run.
 * Filters jobs by 'queued' or the provided status.
 * @async
 * @param {string} username The GitHub username.
 * @param {string} repoName The name of the repository.
 * @param {string} [status='in_progress'] Status to filter workflows (optional).
 * @returns {Promise&lt;Array&lt;{ workflow_run_id: number, workflow_name: string,
 * job_id: number, job_name: string, html_url: string, status: string,
 * started_at: string }>>}
 * Array of running/queued GitHub Action job details.
 * @throws {Error} If API request fails or repository/user not found.
 */
async function listGitHubActions(username, repoName, status = 'in_progress') {
  const urlRuns = `https://api.github.com/repos/${username}/${repoName}/actions/runs?status=${status}`;
  try {
    const runsResponse = await superagent
      .get(urlRuns)
      .set('Authorization', `Bearer ${githubToken}`)
      .set('Accept', 'application/vnd.github+json')
      .set('X-GitHub-Api-Version', GITHUB_API_VERSION)
      .set('User-Agent', USER_AGENT);

    const runsData = runsResponse.body;

    if (!runsData.workflow_runs || runsData.workflow_runs.length === 0) {
      return [];
    }

    const runningJobs = [];
    for (const run of runsData.workflow_runs) {
      const urlJobs = `https://api.github.com/repos/${username}/${repoName}/actions/runs/${run.id}/jobs`;
      const jobsResponse = await superagent
        .get(urlJobs)
        .set('Authorization', `Bearer ${githubToken}`)
        .set('Accept', 'application/vnd.github+json')
        .set('X-GitHub-Api-Version', GITHUB_API_VERSION)
        .set('User-Agent', USER_AGENT);

      const jobsData = jobsResponse.body;

      if (jobsData.jobs) {
        jobsData.jobs.forEach((job) => {
          if (job.status === 'queued' || job.status === status) {
            runningJobs.push({
              workflow_run_id: run.id,
              workflow_name: run.name,
              job_id: job.id,
              job_name: job.name,
              html_url: job.html_url,
              status: job.status,
              started_at: job.started_at,
            });
          }
        });
      }
    }
    return runningJobs;
  } catch (error) {
    logger.error(`Error listing actions (exception): ${username} ${repoName} ${status} ${error}`);
    if (error.response) {
      logger.error(`Error listing actions (exception): ${error.response.text}`);
      if (error.response.status === 404) {
        throw new Error('Not Found: Check user and repo names.');
      }
      if (error.response.body &amp;&amp; error.response.body.errors
        &amp;&amp; error.response.body.errors.length > 0) {
        throw new Error(error.response.body.errors[0].message);
      }
      throw new Error(error.response.body.message || 'Failed to list actions');
    } else {
      throw error;
    }
  }
}

const DEFAULT_DESCRIPTION = 'Repository created by chatapp';

/**
 * Creates a GitHub repository.
 *
 * @async
 * @param {string} repoName - The name of the repository to be created.
 * @param {string} [orgName='user'] - The organization or user username under
 * which the repository will be created. Defaults to 'user'.
 * @param {string} [description=DEFAULT_DESCRIPTION] - A brief description
 * of the repository. Defaults to 'Repository created by app'.
 * @param {boolean} [isPrivate=false] - Whether the repository should be private.
 * @returns {Promise&lt;Object>} - A promise that resolves to an object indicating
 * the success or failure of the operation.
 * @throws {Error} - Throws an error if the API request fails.
 */
async function createRepo(repoName, orgName = 'user', description = DEFAULT_DESCRIPTION, isPrivate = false) {
  const url = (orgName !== 'user')
    ? `https://api.github.com/orgs/${orgName}/repos` : 'https://api.github.com/user/repos';

  // Validate parameters
  if (!repoName || typeof repoName !== 'string') {
    throw new Error('Invalid repository name');
  }

  try {
    const response = await superagent
      .post(url)
      .set('Authorization', `token ${githubToken}`)
      .set('X-GitHub-Api-Version', GITHUB_API_VERSION)
      .set('Accept', 'application/vnd.github+json')
      .set('User-Agent', USER_AGENT)
      .send({
        name: `${repoName}`,
        private: isPrivate,
        description,
      });

    if (response.status === 201) {
      return { success: true, message: 'Repository created' };
    }
    return { success: false, status: response.status, message: response.body.message };
  } catch (error) {
    logger.error('Error creating repo (exception):', orgName, repoName, error);
    throw new Error(`Failed to create repository: ${error.message}`);
  }
}

/**
 * Checks if a GitHub repository exists.
 *
 * This function checks if a specified repository exists under a given user or organization.
 *
 * @async
 * @param {string} username - The username or organization name of the repository owner.
 * @param {string} repoName - The name of the repository to check.
 * @returns {Promise&lt;Object>} - A promise that resolves to an object indicating
 * the existence of the repository.
 * @throws {Error} - Throws an error if the API request fails.
 */
async function checkRepoExists(username, repoName) {
  const url = `https://api.github.com/repos/${username}/${repoName}`;

  // Validate parameters
  if (!username || typeof username !== 'string') {
    throw new Error('Invalid username');
  }
  if (!repoName || typeof repoName !== 'string') {
    throw new Error('Invalid repository name');
  }

  try {
    const response = await superagent
      .get(url)
      .set('Accept', 'application/vnd.github+json')
      .set('Authorization', `token ${githubToken}`)
      .set('User-Agent', USER_AGENT);

    // If the request is successful, the repository exists
    return { exists: true, status: response.status };
  } catch (error) {
    if (error.status === 404) {
      // Repository does not exist
      return { exists: false, status: 404 };
    }
    // Handle other errors
    logger.error('Error checking repository existence (exception):', username, repoName, error);
    throw new Error(`Failed to check repository existence: ${error.message}`);
  }
}

/**
 * Checks if a GitHub branch exists in a specified repository.
 *
 * This function checks if a specified branch exists under a
 * given user or organization and repository.
 *
 * @async
 * @param {string} username - The username or organization name of the repository owner.
 * @param {string} repoName - The name of the repository to check.
 * @param {string} branchName - The name of the branch to check.
 * @returns {Promise&lt;Object>} - A promise that resolves to an object indicating
 * the existence of the branch.
 * @throws {Error} - Throws an error if the API request fails.
 */
async function checkBranchExists(username, repoName, branchName) {
  const url = `https://api.github.com/repos/${username}/${repoName}/branches/${branchName}`;

  // Validate parameters
  if (!username || typeof username !== 'string') {
    throw new Error('Invalid username');
  }
  if (!repoName || typeof repoName !== 'string') {
    throw new Error('Invalid repository name');
  }
  if (!branchName || typeof branchName !== 'string') {
    throw new Error('Invalid branch name');
  }

  try {
    const response = await superagent
      .get(url)
      .set('Accept', 'application/vnd.github+json')
      .set('Authorization', `token ${githubToken}`)
      .set('User-Agent', USER_AGENT);

    // If the request is successful, the branch exists
    return { exists: true, status: response.status };
  } catch (error) {
    if (error.status === 404) {
      // Branch does not exist
      return { exists: false, status: 404 };
    }
    // Handle other errors
    logger.error('Error checking branch existence (exception):', username, repoName, branchName, error);
    throw new Error(`Failed to check branch existence: ${error.message}`);
  }
}

/**
 * Creates a GitHub branch.
 *
 * This function creates a new branch in the specified repository based on an existing reference.
 *
 * @async
 * @param {string} username - The username of the repository owner.
 * @param {string} repoName - The name of the repository where the branch will be created.
 * @param {string} branchName - The name of the new branch to be created.
 * @param {string} baseBranch - The name of the existing branch to base the new
 * branch on (e.g., 'main').
 * @returns {Promise&lt;Object>} - A promise that resolves to an object indicating
 * the success or failure of the operation.
 * @throws {Error} - Throws an error if the API request fails.
 */
async function createBranch(username, repoName, branchName, baseBranch = 'main') {
  const url = `https://api.github.com/repos/${username}/${repoName}/git/refs`;

  // Validate parameters
  if (!username || typeof username !== 'string') {
    throw new Error('Invalid username');
  }
  if (!repoName || typeof repoName !== 'string') {
    throw new Error('Invalid repository name');
  }
  if (!branchName || typeof branchName !== 'string') {
    throw new Error('Invalid branch name');
  }
  if (!baseBranch || typeof baseBranch !== 'string') {
    throw new Error('Invalid base branch name');
  }

  // Check if the branch already exists, if it does, then exit
  try {
    const resp = await checkBranchExists(username, repoName, branchName);
    if (resp.exists) {
      return { success: true, message: 'Branch already exists' };
    }
  } catch (error) {
    logger.error(`Branch check error ${error.message}`);
  }

  try {
    // Get the SHA of the base branch
    const baseBranchResponse = await superagent
      .get(`${url}/heads/${baseBranch}`)
      .set('Authorization', `token ${githubToken}`)
      .set('X-GitHub-Api-Version', GITHUB_API_VERSION)
      .set('Accept', 'application/vnd.github+json')
      .set('User-Agent', USER_AGENT);

    const baseBranchSha = baseBranchResponse.body.object.sha;

    // Create the new branch
    const response = await superagent
      .post(url)
      .set('Authorization', `token ${githubToken}`)
      .set('X-GitHub-Api-Version', GITHUB_API_VERSION)
      .set('Accept', 'application/vnd.github+json')
      .set('User-Agent', USER_AGENT)
      .send({
        ref: `refs/heads/${branchName}`,
        sha: baseBranchSha,
      });

    if (response.status === 201) {
      return { success: true, message: 'Branch created' };
    }
    return { success: false, status: response.status, message: response.body.message };
  } catch (error) {
    const message = error.message || 'Creation failed';
    logger.error(`Error creating branch (exception): ${message}`);
    throw new Error(`Failed to create branch: ${message}`);
  }
}

/**
 * Recursively walks a directory and returns a list of file paths relative to the start directory.
 * @async
 * @param {string} dir The directory to start walking from.
 * @param {string} [rootDir=dir] The original root directory for calculating relative paths.
 * @returns {Promise&lt;string[]>} A promise that resolves to an array of relative file paths.
 */
const walkDir = async (dir, rootDir = dir) => {
  let files = [];
  const entries = await fs.readdir(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      // Recursively walk subdirectories
      files = files.concat(await walkDir(fullPath, rootDir));
    } else if (entry.isFile()) {
      // Add the file path relative to the root directory
      const relativePath = path.relative(rootDir, fullPath);
      files.push(relativePath);
    }
  }
  return files;
};

/**
 * Commits files to a GitHub repository, including files in subdirectories.
 * It checks for existing files to include their SHAs for updates.
 *
 * This function reads all files from a specified directory and its subdirectories
 * and uploads/updates them to the specified GitHub repository, maintaining the
 * directory structure. Each file is encoded in base64.
 *
 * @async
 * @param {string} username - The username of the repository owner.
 * @param {string} repoName - The name of the repository where files will be
 * committed.
 * @param {string} directoryPath - The path to the local directory containing files
 * to upload.
 * @returns {Promise&lt;Object>} - A promise that resolves to an object indicating
 * the success or failure of the operation, with results for each file.
 * @throws {Error} - Throws an error if initial validation or directory reading fails.
 */
const commitFiles = async (username, repoName, directoryPath) => {
  // Validate parameters
  if (!username || typeof username !== 'string') {
    throw new Error('Invalid username');
  }
  if (!repoName || typeof repoName !== 'string') {
    throw new Error('Invalid repository name');
  }
  if (!directoryPath || typeof directoryPath !== 'string') {
    throw new Error('Invalid directory path');
  }
  if (!githubToken) {
    throw new Error('GitHub token is not configured (GITHUB_TOKEN environment variable missing)');
  }

  /* eslint-disable no-continue */
  try {
    // Use walkDir to get all file paths, including those
    // in subdirectories, relative to directoryPath
    const filesToUpload = await walkDir(directoryPath);
    const results = [];

    logger.debug(`Found ${filesToUpload.length} files to process for ${username}/${repoName}`);

    if (filesToUpload.length === 0) {
      return { success: false, message: 'No non-hidden files found in the specified directory to upload', status: 204 };
    }

    for (const relativeFilePath of filesToUpload) {
      const fullLocalFilePath = path.join(directoryPath, relativeFilePath);
      const apiUrl = `https://api.github.com/repos/${username}/${repoName}/contents/${relativeFilePath}`;
      let existingFileSha = null;

      logger.debug(`Processing file: ${relativeFilePath}`);

      try {
        // STEP 1: Check if the file exists and get its SHA
        const getResponse = await superagent
          .get(apiUrl)
          .set('Authorization', `token ${githubToken}`)
          .set('X-GitHub-Api-Version', GITHUB_API_VERSION)
          .set('User-Agent', USER_AGENT)
          .set('Accept', 'application/vnd.github+json');

        if (getResponse.status === 200) {
          // File exists, get its SHA
          existingFileSha = getResponse.body.sha;
          logger.debug(`File exists, retrieved SHA: ${existingFileSha} for ${relativeFilePath}`);
        } else {
          // This case should theoretically not be reached if status is not 404
          logger.warn(`Unexpected status when checking file existence for ${relativeFilePath}: ${getResponse.status}`);
          results.push({ file: relativeFilePath, success: false, message: `Failed to check existence (Status: ${getResponse.status})` });
          continue; // Skip to the next file
        }
      } catch (getError) {
        // Handle error when checking for file existence
        if (getError.response &amp;&amp; getError.response.status === 404) {
          // File does not exist, this is expected for new files
          existingFileSha = null; // Explicitly set to null
          logger.debug(`File does not exist: ${relativeFilePath}`);
        } else {
          // Other errors during GET request
          const status = (getError.response &amp;&amp; getError.response.status) || 'N/A';
          const errorMessage = (getError.response &amp;&amp; getError.response.body
            &amp;&amp; getError.response.body.message) || getError.message;
          logger.error(`Error checking existence of file ${relativeFilePath} [Status: ${status}]`, getError);
          results.push({ file: relativeFilePath, success: false, message: `Failed to check existence: ${errorMessage}` });
          continue; // Skip to the next file
        }
      }

      // STEP 2: Read file content and prepare for PUT
      try {
        const content = await fs.readFile(fullLocalFilePath, { encoding: 'utf8' });
        const base64Content = Buffer.from(content).toString('base64');

        // Prepare the request body, including sha if the file exists
        const putBody = {
          message: existingFileSha ? `Update ${relativeFilePath}` : `Add ${relativeFilePath}`, // Adjust commit message
          content: base64Content,
        };

        if (existingFileSha) {
          putBody.sha = existingFileSha; // Include SHA for updates
          logger.debug(`Preparing to update file: ${relativeFilePath} with SHA ${existingFileSha}`);
        } else {
          logger.debug(`Preparing to create file: ${relativeFilePath}`);
        }

        // STEP 3: Upload/Update the file
        const putResponse = await superagent
          .put(apiUrl)
          .set('Authorization', `token ${githubToken}`)
          .set('X-GitHub-Api-Version', GITHUB_API_VERSION)
          .set('User-Agent', USER_AGENT)
          .set('Accept', 'application/vnd.github+json')
          .send(putBody);

        if ([200, 201].includes(putResponse.status)) {
          const action = existingFileSha ? 'updated' : 'uploaded';
          const newSha = (putResponse.body &amp;&amp; putResponse.body.content
            &amp;&amp; putResponse.body.content.sha) || undefined; // Get the new SHA from the response
          results.push({
            file: relativeFilePath, success: true, message: `File ${action}`, sha: newSha,
          });
          logger.info(`Successfully ${action} file: ${relativeFilePath} [Status: ${putResponse.status}, New SHA: ${newSha}]`);
        } else {
          const errorMessage = (putResponse.body &amp;&amp; putResponse.body.message) || 'Unknown error during PUT';
          logger.warn(`Failed to upload/update file: ${relativeFilePath} [Status: ${putResponse.status}, Message: ${errorMessage}]`);
          results.push({
            file: relativeFilePath,
            success: false,
            status: putResponse.status,
            message: errorMessage,
          });
        }
      } catch (putError) {
        // Error during PUT request (upload/update)
        const status = (putError.response &amp;&amp; putError.response.status) || 'N/A';
        const errorMessage = (putError.response &amp;&amp; putError.response.body
          &amp;&amp; putError.response.body.message) || putError.message;
        logger.error(`Error uploading/updating file: ${relativeFilePath} [Status: ${status}]`, putError);
        results.push({ file: relativeFilePath, success: false, message: `Failed to upload/update: ${errorMessage}` });
      }
    }

    // Check if all uploads were successful
    const allSuccessful = results.every((result) => result.success);

    return { success: allSuccessful, results, message: allSuccessful ? 'All files processed successfully' : 'Some files failed to process' };
  } catch (error) {
    logger.error(`Error processing directory or committing files (exception): ${username}/${repoName} - ${error.message}`, error);
    // Re-throw a clearer error if the initial directory read or setup failed
    throw new Error(`Failed to process files for commit: ${error.message}`);
  }
  /* eslint-enable no-continue */
};

/**
 * Switches the default branch of a GitHub repository.
 *
 * This function updates the specified GitHub repository to change its default branch
 * to the provided branch name. It uses the GitHub API to perform the update.
 *
 * @async
 * @param {string} username - The username of the repository owner.
 * @param {string} repoName - The name of the repository where the default branch will be changed.
 * @param {string} branchName - The name of the branch to set as the new default branch.
 * @returns {Promise&lt;Object>} - A promise that resolves to an object indicating
 *                              the success of the operation,
 *                              with a message confirming the change.
 * @throws {Error} - Throws an error if the API request fails or if
 * there is an issue processing the request.
 */
const switchBranch = async (username, repoName, branchName) => {
  try {
    // Update the repository to change the default branch
    const response = await superagent
      .patch(`https://api.github.com/repos/${username}/${repoName}`)
      .set('Authorization', `token ${githubToken}`)
      .set('X-GitHub-Api-Version', GITHUB_API_VERSION)
      .set('User-Agent', USER_AGENT)
      .set('Accept', 'application/vnd.github+json')
      .send({
        default_branch: branchName,
      });

    if ([200, 201].includes(response.status)) {
      return {
        success: true,
        message: `Default branch changed to "${branchName}" in repository "${username}/${repoName}".`,
      };
    }
    return { success: false, status: response.status, message: response.body.message };
  } catch (error) {
    logger.error(`Error processing switch branch (exception): ${username}/${repoName} - ${error.message}`);
    throw new Error(`Error processing switch branch: ${error.message}`);
  }
};

/* eslint-enable no-restricted-syntax, no-await-in-loop, consistent-return */

module.exports = {
  checkBranchExists,
  checkRepoExists,
  commitFiles,
  createBranch,
  createGithubPullRequest,
  createRepo,
  fetchRepoContentsRecursive,
  listBranches,
  listCommitHistory,
  listDirectoryContents,
  listGitHubActions,
  listPublicRepos,
  switchBranch,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addResponse">addResponse</a></li><li><a href="global.html#availableFunctionsRegistry">availableFunctionsRegistry</a></li><li><a href="global.html#callFunctionByName">callFunctionByName</a></li><li><a href="global.html#checkBranchExists">checkBranchExists</a></li><li><a href="global.html#checkRepoExists">checkRepoExists</a></li><li><a href="global.html#cleanupSession">cleanupSession</a></li><li><a href="global.html#codeReviews">codeReviews</a></li><li><a href="global.html#commitFiles">commitFiles</a></li><li><a href="global.html#createBranch">createBranch</a></li><li><a href="global.html#createGithubPullRequest">createGithubPullRequest</a></li><li><a href="global.html#createRepo">createRepo</a></li><li><a href="global.html#createUniqueTempDir">createUniqueTempDir</a></li><li><a href="global.html#deleteDirectoryRecursively">deleteDirectoryRecursively</a></li><li><a href="global.html#downloadFile">downloadFile</a></li><li><a href="global.html#downloadMutexes">downloadMutexes</a></li><li><a href="global.html#fetchRepoContentsRecursive">fetchRepoContentsRecursive</a></li><li><a href="global.html#funcsMetadata">funcsMetadata</a></li><li><a href="global.html#getAuthToken">getAuthToken</a></li><li><a href="global.html#getAvailableFunctions">getAvailableFunctions</a></li><li><a href="global.html#getChatResponse">getChatResponse</a></li><li><a href="global.html#getDownloadMutex">getDownloadMutex</a></li><li><a href="global.html#getFunctionDefinitionsForTool">getFunctionDefinitionsForTool</a></li><li><a href="global.html#getKey">getKey</a></li><li><a href="global.html#getResponse">getResponse</a></li><li><a href="global.html#getSessionFuncsMetadata">getSessionFuncsMetadata</a></li><li><a href="global.html#getSessionFunctionRegistry">getSessionFunctionRegistry</a></li><li><a href="global.html#getSessionMutex">getSessionMutex</a></li><li><a href="global.html#getSessionTokenMutex">getSessionTokenMutex</a></li><li><a href="global.html#getVehicleHistory">getVehicleHistory</a></li><li><a href="global.html#handleGitHubApiError">handleGitHubApiError</a></li><li><a href="global.html#handleNotFoundError">handleNotFoundError</a></li><li><a href="global.html#listBranches">listBranches</a></li><li><a href="global.html#listCommitHistory">listCommitHistory</a></li><li><a href="global.html#listDirectoryContents">listDirectoryContents</a></li><li><a href="global.html#listGitHubActions">listGitHubActions</a></li><li><a href="global.html#listPublicRepos">listPublicRepos</a></li><li><a href="global.html#mkdir">mkdir</a></li><li><a href="global.html#readContext">readContext</a></li><li><a href="global.html#readFileContent">readFileContent</a></li><li><a href="global.html#readFilesInDirectory">readFilesInDirectory</a></li><li><a href="global.html#readFilesRecursively">readFilesRecursively</a></li><li><a href="global.html#registerFunction">registerFunction</a></li><li><a href="global.html#registryMutex">registryMutex</a></li><li><a href="global.html#saveCodeToFile">saveCodeToFile</a></li><li><a href="global.html#sessionAuthTokens">sessionAuthTokens</a></li><li><a href="global.html#sessionTokenExpiries">sessionTokenExpiries</a></li><li><a href="global.html#sessionTokenMutexes">sessionTokenMutexes</a></li><li><a href="global.html#sessions">sessions</a></li><li><a href="global.html#switchBranch">switchBranch</a></li><li><a href="global.html#walkDir">walkDir</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat May 03 2025 19:03:26 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
