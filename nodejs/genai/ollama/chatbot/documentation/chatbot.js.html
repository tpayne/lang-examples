<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: chatbot.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: chatbot.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const RateLimit = require('express-rate-limit');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const express = require('express');
const fs = require('fs').promises; // Keep the async fs for other operations
const fsSync = require('fs'); // Add sync fs for reading certs synchronously
const path = require('path');
const session = require('express-session');
const util = require('util');
// Add the 'https' module for creating an HTTPS server
const https = require('https');
// Add the 'http' module for creating an HTTP server (for fallback)
const http = require('http');

// Import Ollama
const { Ollama } = require('ollama');
const MemcachedStore = require('connect-memcached')(session);
const { getAvailableFunctions, getFunctionDefinitionsForTool, loadIntegrations } = require('./functions');
const { getConfig, loadProperties } = require('./properties'); // Assuming getConfig is available here
const { cleanupSessionTempDir } = require('./utilities');

dotenv.config();

const app = express();

app.use(express.static(path.join(__dirname, 'public')));

// Rate limiting
const limiter = RateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP/session to 100 requests per windowMs
  keyGenerator: (req) => req.sessionID, // Use session ID for rate limiting
});
app.use(limiter);

// Initialize Ollama client
// Assumes Ollama is running on http://localhost:11434
// You can configure it: const ollama = new Ollama({ host: 'http://custom.host:port' });
const ollama = new Ollama(process.env.OLLAMA_HOST ? { host: process.env.OLLAMA_HOST } : { host: 'http://localhost:11434' });

/**
 * Stores the conversation history and context for each client session.
 * The key is the client's session ID.
 * History is now in OpenAI's messages format.
 * @type {Map&lt;string, { context: string,
 * history: Array&lt;{ role: string, content: string,
 * tool_calls: any[], tool_call_id: string,
 * name: string, function_call: any }>,
 * messageCache: Map&lt;string, string> }>}
 */
const sessions = new Map();

const morganMiddleware = require('./morganmw');
const logger = require('./logger');

// IMPORTANT: Use a dedicated session secret from .env or a default (log warning if default in prod)
const sessionSecret = process.env.SESSION_SECRET || 'your-very-secure-session-secret';
if (sessionSecret === 'your-very-secure-session-secret' &amp;&amp; process.env.NODE_ENV === 'production') {
  logger.warn('WARNING: Using default insecure session secret in production! Please set SESSION_SECRET in your .env file.');
}

app.use(session({
  secret: sessionSecret,
  resave: false,
  saveUninitialized: true,
  store: new MemcachedStore({
    hosts: ['127.0.0.1:11211'], // Default memcached host and port
  }),
  cookie: {
    // Set secure to true only if running HTTPS, false for HTTP fallback
    // This will be handled dynamically based on which server starts
    secure: false, // Initially set to false, will be updated if HTTPS starts
    httpOnly: true, // Prevent client-side access to the cookie
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
  },
}));

/**
 * Function to update session cookie secure flag after server starts.
 * This re-initializes the session middleware with the updated secure flag.
 * @param {boolean} isSecure True if HTTPS is running, false otherwise.
 */
const setSessionSecure = (isSecure) => {
  app.use(session({
    secret: sessionSecret, // Use the same dedicated secret
    resave: false,
    saveUninitialized: true,
    store: new MemcachedStore({
      hosts: ['127.0.0.1:11211'],
    }),
    cookie: {
      secure: isSecure, // Set based on whether HTTPS is running
      httpOnly: true,
      maxAge: 24 * 60 * 60 * 1000,
    },
  }));
};

app.use(bodyParser.json());
app.use(morganMiddleware);

/**
 * Normalizes a string to create a consistent key.
 * @param {string} keyString The string to normalize.
 * @returns {string} The normalized key.
 */
const getKey = (keyString) => keyString.replace(/\W+/g, '').toUpperCase();

/**
 * Adds a query and its response to a specific session's message cache.
 * Limits the cache size per session.
 * @param {string} sessionId The ID of the client session.
 * @param {string} query The user's query.
 * @param {string} response The chatbot's response.
 * @returns {boolean} True if the response was added to the cache.
 */
const addResponse = (sessionId, query, response) => {
  if (!sessions.has(sessionId)) {
    sessions.set(sessionId, {
      context: '', history: [], messageCache: new Map(),
    });
  }
  const xsession = sessions.get(sessionId);
  const cache = xsession.messageCache;
  if (cache.has(getKey(query))) return true; // Avoid adding duplicates
  if (cache.size > 1000) { // Simple cache eviction
    // Evict oldest 100 items
    Array.from(cache.keys()).slice(0, 100).forEach((key) => cache.delete(key));
  }
  cache.set(getKey(query), response);
  return true;
};

/**
 * Retrieves a cached response for a given query within a specific session.
 * @param {string} sessionId The ID of the client session.
 * @param {string} query The user's query.
 * @returns {string} The cached response, or an empty string if not found.
 */
const getResponse = (sessionId, query) => {
  const xsession = sessions.get(sessionId);
  if (xsession &amp;&amp; xsession.messageCache) {
    return xsession.messageCache.get(getKey(query)) || ''; // Return empty string if not found
  }
  return '';
};

/**
 * Reads the context from a file.
 * @async
 * @param {string} contextStr The name of the context file.
 * @returns {Promise&lt;string>} The content of the context file.
 */
const readContext = async (contextStr) => {
  try {
    // Basic path sanitation
    if (contextStr.includes('..') || contextStr.startsWith('/')) {
      throw new Error('Invalid characters in context path');
    }
    const contextPath = path.resolve('contexts', contextStr);
    const normalizedContextPath = path.normalize(contextPath);
    const normalizedContextsPath = path.normalize(path.resolve('contexts'));

    // Ensure the resolved path is within the contexts directory
    if (!normalizedContextPath.startsWith(normalizedContextsPath)) {
      throw new Error('Invalid context path');
    }

    return await fs.readFile(contextPath, 'utf-8');
  } catch (err) {
    logger.error(`Cannot load context '${contextStr}'`, err);
    return '';
  }
};

/**
 * Calls a function by its name with provided arguments.
 * @async
 * @param {string} sessionId The ID of the client session.
 * @param {string} name The name of the function.
 * @param {object} args The arguments for the function (already parsed from JSON string by OpenAI, or directly an object from Ollama).
 * @returns {Promise&lt;any>} The result of the function call, stringified.
 */
const callFunctionByName = async (sessionId, name, args) => {
  const functionCache = await getAvailableFunctions(sessionId);
  const functionInfo = functionCache[name];

  if (functionInfo &amp;&amp; functionInfo.func) {
    try {
      // Destructure 'required' from functionInfo
      const {
        func, params, needSession, required,
      } = functionInfo;
      const functionArgs = { ...args }; // Clone args

      // Check if functionInfo.required exists before filtering
      const missingParams = (required || []).filter((paramName) => functionArgs[paramName] === undefined);

      if (missingParams.length > 0) {
        logger.error(`Missing required arguments for function '${name}': ${missingParams.join(', ')} [Session: ${sessionId}]`);
        return JSON.stringify({ error: `Missing required arguments for function '${name}'`, details: `Missing: ${missingParams.join(', ')}` });
      }

      // Specific validation example
      if (name === 'save_code_to_file' &amp;&amp; typeof functionArgs.code !== 'string') {
        logger.error(`Invalid or missing 'code' argument for save_code_to_file [Session: ${sessionId}]`);
        return JSON.stringify({
          error: 'Invalid or missing \'code\' argument for save_code_to_file',
          details: '\'code\' must be a string.',
        });
      }

      const argValues = params.map((paramName) => functionArgs[paramName]);
      if (needSession) {
        argValues.unshift(sessionId);
      }
      /* eslint-disable prefer-spread */
      logger.info(`Calling Function '${name}' [Session: ${sessionId}]`);
      const result = await func.apply(null, argValues);
      logger.info(`Function '${name}' executed successfully [Session: ${sessionId}]`, { arguments: functionArgs, result });
      /* eslint-enable prefer-spread */

      // Ensure result is stringified if it's an object/array before returning to model
      if (typeof result !== 'string') {
        return JSON.stringify(result);
      }
      return result;
    } catch (error) {
      logger.error(`Error executing function '${name}' [Session: ${sessionId}]`, { arguments: args, error: error.message });
      return JSON.stringify({ error: 'Function execution failed', details: error.message });
    }
  }
  return JSON.stringify({ error: `Function '${name}' not found` });
};

/**
 * Selects relevant functions based on keyword matching in the user's input.
 * This is a simple, local, rule-based approach.
 * @param {string} userInput The user's message.
 * @param {Array&lt;object>} allTools An array of all available tool definitions (Ollama format).
 * @returns {Array&lt;string>} An array of relevant function names.
 */
const selectRelevantFunctionsByKeyword = (userInput, allTools) => {
  const relevantFunctionNames = new Set();
  const lowerCaseInput = userInput.toLowerCase();

  /* eslint-disable no-restricted-syntax */
  for (const tool of allTools) {
    const functionName = tool.function.name;
    const functionDescription = tool.function.description || ''; // Ensure description exists

    // Simple keyword matching: check if input contains function name or parts of it
    // Or if it contains keywords found in the description
    if (lowerCaseInput.includes(functionName.toLowerCase())) {
      relevantFunctionNames.add(functionName);
    } else {
      // More advanced keyword matching could go here, e.g., checking for synonyms,
      // or specific keywords defined for each function.
      // For now, let's also check if input contains any significant word from description.
      const descriptionWords = functionDescription.toLowerCase().split(/\W+/);
      for (const word of descriptionWords) {
        if (word.length > 3 &amp;&amp; lowerCaseInput.includes(word)) { // Avoid very short, common words
          relevantFunctionNames.add(functionName);
          break; // Found a match, move to next tool
        }
      }
    }
  }
  /* eslint-enable no-restricted-syntax */

  logger.info(`Keyword-matched relevant functions: ${Array.from(relevantFunctionNames).join(', ')}`);
  return Array.from(relevantFunctionNames);
};

/**
 * Gets a chat response from the Ollama API, maintaining state per session.
 * Handles special commands, context, caching, and function calling.
 * @async
 * @param {string} sessionId The ID of the client session.
 * @param {string} userInput The user's message.
 * @param {boolean} [forceJson=false] Whether to request a JSON response from Ollama.
 * @returns {Promise&lt;string|object>} The chatbot's response (usually text, or object if forceJson and model returns structured JSON).
 */
const getChatResponse = async (sessionId, userInput, forceJson = false) => {
  // Ensure integrations (and thus available functions) are loaded
  await loadIntegrations(sessionId);

  // Get all function definitions formatted for Ollama tools
  const allAvailableTools = await getFunctionDefinitionsForTool(sessionId);
  let toolsToUse;

  if (allAvailableTools &amp;&amp; allAvailableTools.length > 0) {
    // Select relevant functions using local keyword matching
    const relevantFunctionNames = selectRelevantFunctionsByKeyword(userInput, allAvailableTools);

    // Filter the tools based on the selected relevant function names
    toolsToUse = allAvailableTools.filter((tool) => relevantFunctionNames.includes(tool.function.name));

    if (toolsToUse.length === 0) {
      logger.info(`No relevant functions selected by keyword for input: "${userInput}". Proceeding without tools.`);
      toolsToUse = undefined; // Ensure tools is undefined if no relevant tools are found
    } else {
      logger.info(`Dynamically selected tools for Ollama (keyword-based): ${toolsToUse.map((t) => t.function.name).join(', ')}`);
    }
  }

  let xsession = sessions.get(sessionId); // Retrieve the session

  // Initialize the session if it doesn't exist
  if (!xsession) {
    xsession = {
      context: '', history: [], messageCache: new Map(),
    };
    sessions.set(sessionId, xsession); // Set the newly created session
    logger.info(`Initializing new session [Session: ${sessionId}]`);
  }

  // Handle special commands per session before interacting with the model
  const lowerInput = userInput.toLowerCase().trim();
  if (lowerInput === 'help') return 'Sample *Help* text';
  if (lowerInput.startsWith('bot-echo-string')) {
    return userInput.substring('bot-echo-string'.length).trim() || 'No string to echo';
  }
  if (lowerInput.startsWith('bot-context')) {
    const parts = lowerInput.split(' ').map((p) => p.trim()).filter((p) => p);
    const command = parts[1];
    const arg = parts.slice(2).join(' ');

    switch (command) {
      case 'load':
        if (!arg) return 'Usage: bot-context load &lt;context_file_name>';
        /* eslint-disable no-case-declarations */
        const newContext = await readContext(arg);
        /* eslint-enable no-case-declarations */
        if (newContext) {
          xsession.context = newContext;
          xsession.history = [{ role: 'system', content: xsession.context }]; // Reset history with new system context
          xsession.messageCache = new Map(); // Clear cache as context changed
          logger.info(`Context '${arg}' loaded and session reset [Session: ${sessionId}]`);
          return `Context '${arg}' loaded and session reset`;
        }
        logger.warn(`Context file '${arg}' could not be read or is empty [Session: ${sessionId}]`);
        return `Context file '${arg}' could not be read or is empty`;

      case 'show':
        return xsession.context || 'Context is empty for this session';
      case 'reset':
        cleanupSessionTempDir(sessionId);
        xsession.context = '';
        xsession.history = []; // Clear history
        xsession.messageCache = new Map(); // Clear cache
        logger.info(`Context, chat history, and cache reset [Session: ${sessionId}]`);
        return 'Context, chat history, and cache reset for this session';
      default:
        return 'Invalid bot-context command. Use: load &lt;file>, show, reset';
    }
  }

  // If context is required and not set, inform the user
  if (!xsession.context &amp;&amp; getConfig().requireContext === 'true') {
    return 'Error: Context is required and not set for this session. Please use "bot-context load &lt;file>" to load one.';
  }

  // Check cache before calling the API
  const cachedResponse = getResponse(sessionId, userInput);
  if (cachedResponse) {
    logger.info(`Returning cached response [Session: ${sessionId}]`);
    return cachedResponse;
  }

  try {
    // Add system message if context exists and it's the first message or history is empty
    if (xsession.context &amp;&amp; (xsession.history.length === 0 || xsession.history[0].role === 'user' || xsession.history[0].role === 'assistant' || xsession.history[0].role === 'tool')) {
      xsession.history.unshift({ role: 'system', content: xsession.context });
      logger.info(`Added system message from context [Session: ${sessionId}]`);
    } else if (!xsession.context &amp;&amp; xsession.history.length > 0 &amp;&amp; xsession.history[0].role === 'system') {
      // If context was removed, remove the old system message
      xsession.history.shift();
      logger.info(`Removed system message (context is empty) [Session: ${sessionId}]`);
    }

    // Add the user's message to the history for this turn
    xsession.history.push({ role: 'user', content: userInput });
    logger.debug(`Added user message to history [Session: ${sessionId}]`);

    let chatResponseContent = null;
    let numSteps = 0;
    const maxSteps = getConfig().maxChatSteps; // Limit steps (API calls + function calls)

    // Loop to handle potential function calls and subsequent AI responses
    /* eslint-disable no-await-in-loop, no-plusplus, no-restricted-syntax */
    // Line 247:3
    while (numSteps &lt; maxSteps) {
      numSteps++;

      const ollamaOptions = {
        temperature: Number(getConfig().temperature),
        top_p: Number(getConfig().top_p),
        // Other Ollama specific options can be added here from config
        // e.g., num_ctx, repeat_penalty, mirostat, etc.
      };

      const maxTokensConfig = getConfig().maxTokens;
      if (maxTokensConfig &amp;&amp; maxTokensConfig !== 'auto') {
        const numPredict = Number(maxTokensConfig);
        // Fix: Use Number.isNaN instead of global isNaN
        if (!Number.isNaN(numPredict) &amp;&amp; numPredict > 0) {
          ollamaOptions.num_predict = numPredict; // Max tokens for Ollama
        } else if (numPredict !== -1) { // Allow -1 for infinite generation if explicitly set
          logger.warn(`Invalid maxTokens value '${maxTokensConfig}', using Ollama's default for num_predict. Set to -1 for 'infinite'.`);
        } else {
          ollamaOptions.num_predict = -1; // User explicitly wants infinite
        }
      }

      const requestPayload = {
        model: getConfig().aiModel, // e.g., 'llama3', 'mistral'
        messages: xsession.history, // Send the full conversation history
        stream: false, // We are not using streaming in this example
        tools: toolsToUse, // Pass the dynamically selected tools here for Ollama
        options: ollamaOptions,
      };

      if (forceJson) {
        requestPayload.format = 'json'; // Request JSON output from Ollama
        logger.info(`Requesting JSON response format from Ollama [Session: ${sessionId}]`);
      }

      logger.debug(`Ollama API request [Session: ${sessionId}]: ${util.inspect(requestPayload, { depth: 3 })}`); // Log request
      const response = await ollama.chat(requestPayload);
      logger.debug(`Ollama API response [Session: ${sessionId}]: ${util.inspect(response, { depth: null })}`); // Log full response

      const { message } = response; // Ollama response structure

      if (!message) {
        logger.warn(`Ollama API: No message in response [Session: ${sessionId}]`);
        chatResponseContent = 'Could not get a valid message from the model.';
        break;
      }

      // Initialize an empty array for tool calls that we might parse
      let parsedToolCalls = [];

      // Check if the Ollama API directly provided structured tool_calls
      if (message.tool_calls &amp;&amp; message.tool_calls.length > 0) {
        parsedToolCalls = message.tool_calls;
      } else if (message.content) {
        // Attempt to parse message.content for tool calls if it looks like a JSON array of tool calls
        try {
          // Regular expression to find JSON array at the start of the content, possibly with leading whitespace
          const jsonMatch = message.content.match(/^(\s*\[\s*\{.*\}\s*\])/s);
          if (jsonMatch) {
            const potentialToolCallsString = jsonMatch[1];
            // Remove the parsed tool call JSON string from the content, leaving only the natural language part
            const contentAfterToolCalls = message.content.substring(potentialToolCallsString.length).trim();

            const parsed = JSON.parse(potentialToolCallsString);
            // Basic validation to ensure it's an array of objects that look like tool calls
            if (Array.isArray(parsed) &amp;&amp; parsed.every(tc => tc.name &amp;&amp; tc.arguments !== undefined)) {
              parsedToolCalls = parsed.map(tc => ({
                id: tc.id || `call_${Math.random().toString(36).substring(2, 9)}`, // Generate a unique ID if not provided by model
                function: {
                  name: tc.name,
                  arguments: tc.arguments
                }
              }));
              message.content = contentAfterToolCalls; // Update message.content to reflect only the textual part
              logger.info(`Parsed tool call(s) from message.content [Session: ${sessionId}]`);
            }
          }
        } catch (parseError) {
          logger.debug(`Could not parse message.content as tool calls (likely not a tool call JSON): ${parseError.message} [Session: ${sessionId}]`);
          // Continue if parsing fails, it's just text content
        }
      }

      // Add assistant's response (which might include tool calls, either direct or parsed) to history
      const assistantMessageToPush = {
        role: message.role,
        content: message.content, // This will now be the natural language part if tool calls were parsed from content
        ...(parsedToolCalls.length > 0 &amp;&amp; { tool_calls: parsedToolCalls }),
      };
      xsession.history.push(assistantMessageToPush);
      logger.debug(`Added assistant message to history [Session: ${sessionId}]`, {
        role: message.role,
        content: message.content,
        tool_calls: parsedToolCalls.length,
      });

      // Now, use parsedToolCalls for the logic
      // Line 260:7
      if (parsedToolCalls.length > 0) {
        logger.info(`Tool call(s) initiated by Ollama model (parsed from content or direct) [Session: ${sessionId}]`);
        // Process all tool calls issued by the model in this turn
        for (const toolCall of parsedToolCalls) { // Iterate over parsedToolCalls
          const functionName = toolCall.function.name;
          const functionArgs = toolCall.function.arguments; // This is an object from Ollama
          const toolCallId = toolCall.id; // ID for linking the tool call and its result

          if (!toolCallId) {
            logger.warn(`Tool call from Ollama for function ${functionName} is missing an ID. This might cause issues with tool result attribution. [Session: ${sessionId}]`);
            // Depending on strictness, you might want to throw an error or generate a temp ID.
          }

          logger.info(`Tool call details [Session: ${sessionId}], Name: ${functionName}, Args: ${JSON.stringify(functionArgs)}, ID: ${toolCallId}`);

          let functionCallResult;
          try {
            functionCallResult = await callFunctionByName(sessionId, functionName, functionArgs);
            // Ensure the result is a string as expected by the history.
            if (typeof functionCallResult !== 'string') {
              functionCallResult = JSON.stringify(functionCallResult);
            }
          } catch (error) {
            logger.error(`Error during tool call execution or parsing arguments for ${functionName} [Session: ${sessionId}]`, error);
            functionCallResult = JSON.stringify({ error: 'Function execution or argument parsing failed', details: error.message });
          }

          // Log the structured result if it's JSON, otherwise log as is.
          try {
            const parsedResult = JSON.parse(functionCallResult);
            logger.info(`Tool call result [Session: ${sessionId}], ${functionName} => ${JSON.stringify(parsedResult, null, 2)}`);
          } catch (error) {
            logger.info(`Tool call result (non-JSON or parsing error) [Session: ${sessionId}], ${functionName} => ${functionCallResult}`);
          }

          // Add the tool result to the history
          const toolResponseMessage = {
            role: 'tool',
            content: functionCallResult, // Result of the function call (as a string)
          };
          // Crucially, add tool_call_id to link it back to the assistant's request.
          if (toolCallId) {
            toolResponseMessage.tool_call_id = toolCallId;
          }

          xsession.history.push(toolResponseMessage);
          logger.debug(`Added tool result to history [Session: ${sessionId}]`, toolResponseMessage);
        }
        // The loop continues, and the next API call will include the tool result message(s).
        // The model will then likely generate a text response based on the tool result(s).
      } else if (message.content) {
        // If no tool calls (either direct or parsed), and there is content, this is the final response for this turn
        chatResponseContent = message.content;
        logger.info(`Received final text response from Ollama [Session: ${sessionId}]`);
        cleanupSessionTempDir(sessionId); // Clean up temp directory if used
        break; // Exit loop as we have the final text response
      } else {
        // Handle cases where message exists but has neither content nor tool_calls
        logger.warn(`Ollama API: Received message with no content or tool_calls [Session: ${sessionId}]`, message);
        chatResponseContent = 'Received an unexpected response format from the model.';
        break;
      }

      // Check if Ollama model indicates it's done (e.g. after tool calls, it might not be done yet)
      // `response.done` from ollama.chat indicates if the specific chat turn is complete.
      // If it's false after tool calls, `response.done` should generally be true for non-streaming.
      if (!response.done &amp;&amp; numSteps >= maxSteps) {
        logger.warn(`Ollama API: Max steps reached, but model indicates it's not done processing its current turn. [Session: ${sessionId}]`);
      }
    }
    /* eslint-enable no-await-in-loop, no-plusplus, no-restricted-syntax */

    if (!chatResponseContent) {
      // If loop finished without a final text response
      logger.warn(`Ollama API: Max steps reached or no final text response generated [Session: ${sessionId}]`);
      chatResponseContent = 'Reached maximum processing steps or could not get a final text response from the model.';
    }

    // Ensure history doesn't grow indefinitely
    const maxHistoryLength = 500; // Adjust as needed for Ollama models
    if (xsession.history.length > maxHistoryLength) {
      // Keep the system message and the last N turns
      const systemMessage = xsession.history.find((msg) => msg.role === 'system');
      let historyToKeep = systemMessage ? [systemMessage] : [];
      const messagesWithoutSystem = xsession.history.filter((msg) => msg.role !== 'system');
      const messagesToKeep = messagesWithoutSystem.slice(
        -(maxHistoryLength - (systemMessage ? 1 : 0)),
      );
      historyToKeep = historyToKeep.concat(messagesToKeep);
      xsession.history = historyToKeep;
      logger.debug(`Trimmed history to ${xsession.history.length} messages [Session: ${sessionId}]`);
    }

    addResponse(sessionId, userInput, chatResponseContent);
    return chatResponseContent;
  } catch (err) {
    logger.error(`Ollama API error or processing error [Session: ${sessionId}]`, err);
    // Provide more informative error to the user
    if (err.message &amp;&amp; err.message.includes('model not found')) {
      return `Error: The specified Ollama model '${getConfig().aiModel}' was not found. Please ensure it is pulled and spelled correctly.`;
    }
    if (err.cause &amp;&amp; err.cause.code === 'ECONNREFUSED') { // Node.js HTTP errors often have err.cause
      return `Error: Could not connect to Ollama. Please ensure Ollama is running. (${err.message})`;
    }
    return `Error processing your request with Ollama: ${err.message}. Please try again or contact support.`;
  }
};

/**
 * Handles incoming chat requests.
 * @async
 * @param {express.Request} req The Express request object.
 * @param {express.Response} res The Express response object.
 * @returns {Promise&lt;void>}
 */
app.post('/chat', async (req, res) => {
  const userMessage = req.body.message;
  // Use sessionID if available, fallback to IP (less reliable for sessions but a fallback)
  const sessionId = req.sessionID || req.ip;

  if (!userMessage) {
    logger.warn(`Chat request with empty message [Session: ${sessionId}]`);
    return res.status(400).json({ error: 'Message is required' });
  }

  logger.info(`Chat request received [Session: ${sessionId}]`, { message: userMessage });

  try {
    const resp = await getChatResponse(sessionId, userMessage);
    // The response from getChatResponse is intended to be the final text response
    return res.json({ response: resp });
  } catch (error) {
    // This catch is for unexpected errors not handled within getChatResponse
    logger.error(`Unhandled error in /chat route [Session: ${sessionId}]`, error);
    return res.status(500).json({ error: 'An internal server error occurred.' });
  }
});

// Serve static files from 'public' directory
app.use(express.static(path.join(__dirname, 'public')));

/**
 * Serves the index.html file for the root path.
 * @param {express.Request} req The Express request object.
 * @param {express.Response} res The Express response object.
 * @returns {void}
 */
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'templates', 'indexBot.html'));
});

/**
 * Returns the current version of the chatbot.
 * @param {express.Request} req The Express request object.
 * @param {express.Response} res The Express response object.
 * @returns {void}
 */
app.get('/version', (req, res) => res.json({ version: '1.0-ollama' })); // Updated version string

/**
 * Returns the current status of the chatbot.
 * @param {express.Request} req The Express request object.
 * @param {express.Response} res The Express response object.
 * @returns {void}
 */
app.get('/status', (req, res) => res.json({ status: 'live' }));

/**
 * Handles graceful shutdown of the server.
 * @param {string} signal The signal received (e.g., 'SIGINT', 'SIGTERM').
 */
const shutdown = (signal) => {
  logger.info(`${signal} received. Shutting down gracefully.`);
  // Add any cleanup logic here (e.g., closing database connections, saving sessions if needed)
  process.exit(0);
};

process.on('SIGINT', () => shutdown('SIGINT')); // Ctrl+C
process.on('SIGTERM', () => shutdown('SIGTERM')); // kill command

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection at:', promise, 'reason:', reason);
  // Application specific logging, throwing an error, or other logic here
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  logger.error('Uncaught Exception:', err);
  // This is a critical error, the process is in an undefined state.
  // Perform minimal cleanup if possible and then exit.
  shutdown('UncaughtException'); // Exit after logging
});

/**
 * Initializes and starts the Express server (HTTPS with HTTP fallback).
 */
const startServer = () => {
  if (!loadProperties('resources/app.properties')) {
    logger.error('Failed to load application properties. Exiting.');
    process.exit(1); // Critical error: properties not loaded
  }

  const host = getConfig().host || '0.0.0.0'; // Allow host to be configured, default to all interfaces

  // --- Attempt to start HTTPS Server ---
  let privateKey = null;
  let certificate = null;
  // Default path for certificates, can be overridden by config
  const certsPath = getConfig().certsPath || path.join(__dirname, 'certs'); // More sensible default path

  try {
    // Read certificate files synchronously as they are needed at startup
    privateKey = fsSync.readFileSync(path.join(certsPath, 'server.key'), 'utf8');
    certificate = fsSync.readFileSync(path.join(certsPath, 'server.crt'), 'utf8');
    // Uncomment if you have a CA certificate chain file
    // const ca = fsSync.readFileSync(path.join(certsPath, 'ca.crt'), 'utf8');

    const credentials = {
      key: privateKey,
      cert: certificate,
      // ca: ca // Uncomment if you have a certificate chain
    };

    const httpsPort = Number(getConfig().httpsPort) || 8443;
    const httpsServer = https.createServer(credentials, app);

    httpsServer.listen(httpsPort, host, () => {
      logger.info(`HTTPS Listening on ${host}:${httpsPort}`);
      setSessionSecure(true); // Set session cookie to secure for HTTPS
    });

    logger.info('HTTPS server started successfully.');

    // Optional: If you also want an HTTP server for redirection or non-sensitive health checks
    // const httpPortForRedirect = Number(getConfig().port) || 8080;
    // http.createServer((req, res) => {
    //   res.writeHead(301, { "Location": "https://" + req.headers['host'] + req.url });
    //   res.end();
    // }).listen(httpPortForRedirect, host, () => {
    //   logger.info(`HTTP server for redirection listening on ${host}:${httpPortForRedirect}`);
    // });
  } catch (err) {
    // --- Fallback to HTTP Server ---
    logger.warn(`Failed to load SSL certificates or start HTTPS server (Error: ${err.message}). Falling back to HTTP.`);
    logger.info(`Ensure 'server.key' and 'server.crt' are in '${certsPath}' or configure 'certsPath' in properties.`);

    const httpPort = Number(getConfig().port) || 8080;
    const httpServer = http.createServer(app); // Create an HTTP server

    httpServer.listen(httpPort, host, () => {
      logger.info(`HTTP Listening on ${host}:${httpPort}`);
      setSessionSecure(false); // Ensure session cookie is not secure for HTTP
    });

    logger.info('HTTP server started as fallback.');
  }
};

// Start the server
startServer();</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-utilities.html">utilities</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addResponse">addResponse</a></li><li><a href="global.html#authenticateDockerHub">authenticateDockerHub</a></li><li><a href="global.html#availableFunctionsRegistry">availableFunctionsRegistry</a></li><li><a href="global.html#callFunctionByName">callFunctionByName</a></li><li><a href="global.html#callKubernetesApi">callKubernetesApi</a></li><li><a href="global.html#checkBranchExists">checkBranchExists</a></li><li><a href="global.html#checkRepoExists">checkRepoExists</a></li><li><a href="global.html#cleanupSession">cleanupSession</a></li><li><a href="global.html#cleanupSessionTempDir">cleanupSessionTempDir</a></li><li><a href="global.html#codeReviews">codeReviews</a></li><li><a href="global.html#commitFiles">commitFiles</a></li><li><a href="global.html#createBranch">createBranch</a></li><li><a href="global.html#createGithubPullRequest">createGithubPullRequest</a></li><li><a href="global.html#createKubernetesResource">createKubernetesResource</a></li><li><a href="global.html#createRepo">createRepo</a></li><li><a href="global.html#createUniqueTempDir">createUniqueTempDir</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#deleteDirectoryRecursively">deleteDirectoryRecursively</a></li><li><a href="global.html#deleteKubernetesResource">deleteKubernetesResource</a></li><li><a href="global.html#downloadFile">downloadFile</a></li><li><a href="global.html#downloadMutexes">downloadMutexes</a></li><li><a href="global.html#fetchRepoContentsRecursive">fetchRepoContentsRecursive</a></li><li><a href="global.html#funcsMetadata">funcsMetadata</a></li><li><a href="global.html#generateGoogleMapsLink">generateGoogleMapsLink</a></li><li><a href="global.html#getAuthToken">getAuthToken</a></li><li><a href="global.html#getAvailableFunctions">getAvailableFunctions</a></li><li><a href="global.html#getChatResponse">getChatResponse</a></li><li><a href="global.html#getDefaultBranch">getDefaultBranch</a></li><li><a href="global.html#getDockerImageTags">getDockerImageTags</a></li><li><a href="global.html#getDownloadMutex">getDownloadMutex</a></li><li><a href="global.html#getFunctionDefinitionsForTool">getFunctionDefinitionsForTool</a></li><li><a href="global.html#getKey">getKey</a></li><li><a href="global.html#getKubernetesDeploymentDetails">getKubernetesDeploymentDetails</a></li><li><a href="global.html#getKubernetesNodeDetails">getKubernetesNodeDetails</a></li><li><a href="global.html#getKubernetesPodDetails">getKubernetesPodDetails</a></li><li><a href="global.html#getKubernetesPodLogs">getKubernetesPodLogs</a></li><li><a href="global.html#getKubernetesSecretDetails">getKubernetesSecretDetails</a></li><li><a href="global.html#getKubernetesServiceDetails">getKubernetesServiceDetails</a></li><li><a href="global.html#getKubernetesVersion">getKubernetesVersion</a></li><li><a href="global.html#getOrCreateSessionTempDir">getOrCreateSessionTempDir</a></li><li><a href="global.html#getResponse">getResponse</a></li><li><a href="global.html#getSessionFuncsMetadata">getSessionFuncsMetadata</a></li><li><a href="global.html#getSessionFunctionRegistry">getSessionFunctionRegistry</a></li><li><a href="global.html#getSessionTokenMutex">getSessionTokenMutex</a></li><li><a href="global.html#getVehicleHistory">getVehicleHistory</a></li><li><a href="global.html#handleGitHubApiError">handleGitHubApiError</a></li><li><a href="global.html#handleNotFoundError">handleNotFoundError</a></li><li><a href="global.html#listBranches">listBranches</a></li><li><a href="global.html#listCommitHistory">listCommitHistory</a></li><li><a href="global.html#listDirectoryContents">listDirectoryContents</a></li><li><a href="global.html#listGitHubActions">listGitHubActions</a></li><li><a href="global.html#listKubernetesConfigMaps">listKubernetesConfigMaps</a></li><li><a href="global.html#listKubernetesCronJobs">listKubernetesCronJobs</a></li><li><a href="global.html#listKubernetesDaemonSets">listKubernetesDaemonSets</a></li><li><a href="global.html#listKubernetesDeployments">listKubernetesDeployments</a></li><li><a href="global.html#listKubernetesEvents">listKubernetesEvents</a></li><li><a href="global.html#listKubernetesIngresses">listKubernetesIngresses</a></li><li><a href="global.html#listKubernetesJobs">listKubernetesJobs</a></li><li><a href="global.html#listKubernetesNamespaces">listKubernetesNamespaces</a></li><li><a href="global.html#listKubernetesNodes">listKubernetesNodes</a></li><li><a href="global.html#listKubernetesPersistentVolumeClaims">listKubernetesPersistentVolumeClaims</a></li><li><a href="global.html#listKubernetesPersistentVolumes">listKubernetesPersistentVolumes</a></li><li><a href="global.html#listKubernetesPods">listKubernetesPods</a></li><li><a href="global.html#listKubernetesReplicaSets">listKubernetesReplicaSets</a></li><li><a href="global.html#listKubernetesSecrets">listKubernetesSecrets</a></li><li><a href="global.html#listKubernetesServices">listKubernetesServices</a></li><li><a href="global.html#listKubernetesStatefulSets">listKubernetesStatefulSets</a></li><li><a href="global.html#listPublicRepos">listPublicRepos</a></li><li><a href="global.html#loadKubernetes">loadKubernetes</a></li><li><a href="global.html#loadMappingFunctions">loadMappingFunctions</a></li><li><a href="global.html#mkdir">mkdir</a></li><li><a href="global.html#planRoute">planRoute</a></li><li><a href="global.html#readContext">readContext</a></li><li><a href="global.html#registerFunction">registerFunction</a></li><li><a href="global.html#registryMutex">registryMutex</a></li><li><a href="global.html#saveCodeToFile">saveCodeToFile</a></li><li><a href="global.html#scaleKubernetesDeployment">scaleKubernetesDeployment</a></li><li><a href="global.html#searchDockerImages">searchDockerImages</a></li><li><a href="global.html#selectRelevantFunctionsByKeyword">selectRelevantFunctionsByKeyword</a></li><li><a href="global.html#sessionAuthTokens">sessionAuthTokens</a></li><li><a href="global.html#sessionTokenExpiries">sessionTokenExpiries</a></li><li><a href="global.html#sessionTokenMutexes">sessionTokenMutexes</a></li><li><a href="global.html#sessions">sessions</a></li><li><a href="global.html#setSessionSecure">setSessionSecure</a></li><li><a href="global.html#shutdown">shutdown</a></li><li><a href="global.html#startServer">startServer</a></li><li><a href="global.html#switchBranch">switchBranch</a></li><li><a href="global.html#updateKubernetesResource">updateKubernetesResource</a></li><li><a href="global.html#walkDir">walkDir</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat May 31 2025 18:12:27 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
