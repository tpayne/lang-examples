<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: functions.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: functions.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { Mutex } = require('async-mutex'); // Import Mutex for thread safety
const logger = require('./logger');

const {
  commitFiles,
  createGithubPullRequest,
  createRepo,
  fetchRepoContentsRecursive,
  listBranches,
  listCommitHistory,
  listDirectoryContents,
  listGitHubActions,
  listPublicRepos,
} = require('./gitFunctions');

const {
  codeReviews,
  cleanupSession: cleanupCodeReviewSession, // Import cleanup for code reviews
} = require('./codeReviews');

const {
  getVehicleHistory,
} = require('./dosaFunctions');

/* eslint-disable max-len */

/**
 * @typedef {object} FunctionMetadata
 * @property {string} type - The type of the tool, typically 'function'.
 * @property {object} function - The function definition.
 * @property {string} function.name - The name of the function.
 * @property {string} function.description - A description of what the function does.
 * @property {object} function.parameters - The parameters the function accepts.
 * @property {string} function.parameters.type - The type of the parameters object ('object').
 * @property {object} function.parameters.properties - The individual parameters.
 * @property {object} function.parameters.properties.[parameterName] - Metadata for a specific parameter.
 * @property {string} function.parameters.properties.[parameterName].type - The type of the parameter (e.g., 'string', 'number', 'boolean').
 * @property {string} function.parameters.properties.[parameterName].description - A description of the parameter.
 * @property {string[]} function.parameters.required - An array of required parameter names.
 */

/**
 * @typedef {object} RegisteredFunction
 * @property {Function} func - The actual JavaScript function to execute.
 * @property {string[]} params - An array of parameter names the function expects.
 */

/**
 * Registry of available GitHub functions for AI, keyed by session ID.
 * @type {Map&lt;string, Record&lt;string, RegisteredFunction>>}
 */
const availableFunctionsRegistry = new Map();

/**
 * Metadata for GitHub functions as AI tools, stored per session.
 * @type {Map&lt;string, FunctionMetadata[]>}
 */
const funcsMetadata = new Map();

/**
 * Mutex to control access to the function registries.
 * @type {Mutex}
 */
const registryMutex = new Mutex();

/**
 * Gets or creates the function registry for a given session ID.
 * @param {string} sessionId The unique identifier for the session.
 * @returns {Record&lt;string, RegisteredFunction>} The function registry for the session.
 */
async function getSessionFunctionRegistry(sessionId) {
  const release = await registryMutex.acquire();
  try {
    if (!availableFunctionsRegistry.has(sessionId)) {
      availableFunctionsRegistry.set(sessionId, {});
    }
    return availableFunctionsRegistry.get(sessionId);
  } finally {
    release();
  }
}

/**
 * Gets or creates the function metadata array for a given session ID.
 * @param {string} sessionId The unique identifier for the session.
 * @returns {FunctionMetadata[]} The function metadata array for the session.
 */
async function getSessionFuncsMetadata(sessionId) {
  const release = await registryMutex.acquire();
  try {
    if (!funcsMetadata.has(sessionId)) {
      funcsMetadata.set(sessionId, []);
    }
    return funcsMetadata.get(sessionId);
  } finally {
    release();
  }
}

/**
 * Registers a new function for AI for a specific session.
 * @param {string} sessionId The unique identifier for the session.
 * @param {string} name - The unique name of the function (used as the key).
 * @param {Function} func - The JavaScript function to execute.
 * @param {string[]} params - An array of parameter names the function expects.
 * @param {string} description - A description of what the function does.
 * @param {object} parametersSchema - The JSON schema for the function's parameters.
 * @param {string[]} required - An array of required parameter names.
 * @param {boolean} needSession - Session needed
 */
async function registerFunction(
  sessionId,
  name,
  func,
  params,
  description,
  parametersSchema,
  required,
  needSession = false,
) {
  const sessionRegistry = await getSessionFunctionRegistry(sessionId);
  const sessionFuncs = await getSessionFuncsMetadata(sessionId);

  const release = await registryMutex.acquire();
  try {
    if (sessionRegistry[name]) {
      logger.warn(`Function with name '${name}' already registered for session '${sessionId}' and will be reused.`);
    } else {
      sessionRegistry[name] = { func, params, needSession };

      const functionMetadata = {
        type: 'function',
        function: {
          name,
          description,
          parameters: {
            type: 'object',
            properties: parametersSchema,
            required,
          },
        },
      };
      sessionFuncs.push(functionMetadata);
    }
  } finally {
    release();
  }
}

/* eslint-disable no-shadow */

async function loadCodeReviews(sessionId) {
  await registerFunction(
    sessionId,
    'file_review',
    (sessionId, username, repoName, repoPath) => codeReviews(sessionId, username, repoName, repoPath),
    ['username', 'repoName', 'repoPath'],
    'Review files in a given GitHub repository.',
    {
      username: { type: 'string', description: 'The GitHub username.' },
      repoName: { type: 'string', description: 'The repository name.' },
      repoPath: { type: 'string', description: 'The GitHub repository path to start download at.' },
    },
    ['username', 'repoName', 'repoPath'],
    true,
  );
}

async function loadDosa(sessionId) {
  await registerFunction(
    sessionId,
    'get_mot_history',
    (sessionId, registrationNumber) => getVehicleHistory(sessionId, registrationNumber),
    ['registrationNumber'],
    'Get the MOT History for a vehicle.',
    {
      registrationNumber: { type: 'string', description: 'The Vehicle registration or VIN number.' },
    },
    ['registrationNumber'],
    true,
  );
}

/* eslint-enable no-shadow */

async function loadGitHub(sessionId) {
  await registerFunction(
    sessionId,
    'create_repo',
    createRepo,
    ['repoName', 'orgName', 'description', 'isPrivate'],
    'Create a GitHub repository under an organisation or user',
    {
      repoName: { type: 'string', description: 'The repository name.' },
      orgName: { type: 'string', description: 'The GitHub organisation to use (optional). Defaults to user repository.' },
      description: { type: 'string', description: 'The description of the repository name (optional). Defaults if not provided' },
      isPrivate: { type: 'boolean', description: 'Is the repository private (true) or public (false) (optional). Defaults to public if not provided' },
    },
    ['repoName'],
  );

  await registerFunction(
    sessionId,
    'commit_files',
    commitFiles,
    ['username', 'repoName', 'directoryPath'],
    'Uploads or commits files in a directory to a specified GitHub repository.',
    {
      username: { type: 'string', description: 'The GitHub username.' },
      repoName: { type: 'string', description: 'The repository name.' },
      directoryPath: { type: 'string', description: 'The local directory path that contains the files to upload/commit to the repository.' },
    },
    ['username', 'repoName', 'directoryPath'],
  );

  await registerFunction(
    sessionId,
    'create_pull_request',
    createGithubPullRequest,
    ['username', 'repoName', 'title', 'sourceBranch', 'targetBranch', 'body'],
    'Create a pull request on a given GitHub repository.',
    {
      username: { type: 'string', description: 'The GitHub username.' },
      repoName: { type: 'string', description: 'The repository name.' },
      title: { type: 'string', description: 'The Pull Request title.' },
      sourceBranch: { type: 'string', description: 'The source branch name.' },
      targetBranch: { type: 'string', description: 'The target branch name.' },
      body: { type: 'string', description: 'The description or body of the pull request.' },
    },
    ['username', 'repoName', 'title', 'sourceBranch', 'targetBranch'],
  );

  await registerFunction(
    sessionId,
    'fetch_repo_contents',
    fetchRepoContentsRecursive,
    ['username', 'repoName', 'repoPath', 'localDestPath', 'includeDotGithub', 'retryCount', 'maxRetries'],
    'Fetch or download the contents of a GitHub repository.',
    {
      username: { type: 'string', description: 'The GitHub username.' },
      repoName: { type: 'string', description: 'The repository name.' },
      repoPath: { type: 'string', description: 'The GitHub repository path to start download at.' },
      localDestPath: { type: 'string', description: 'The target local directory path to download to.' },
      includeDotGithub: { type: 'boolean', description: 'A boolean to include .github metadata or not.' },
      retryCount: { type: 'number', description: 'The retry count to use.' },
      maxRetries: { type: 'number', description: 'The maximum number of retries.' },
    },
    ['username', 'repoName', 'repoPath', 'localDestPath', 'includeDotGithub', 'retryCount', 'maxRetries'],
    true,
  );

  await registerFunction(
    sessionId,
    'list_actions',
    listGitHubActions,
    ['username', 'repoName', 'status'],
    'Lists the GitHub actions running in a GitHub repository.',
    {
      username: { type: 'string', description: 'The GitHub username.' },
      repoName: { type: 'string', description: 'The repository name.' },
      status: { type: 'string', description: 'The status of the actions (optional). Defaults to in_progress if not provided' },
    },
    ['username', 'repoName'],
  );

  await registerFunction(
    sessionId,
    'list_public_repos',
    listPublicRepos,
    ['username'],
    'Lists public repositories for a given GitHub username.',
    {
      username: { type: 'string', description: 'The GitHub username.' },
    },
    ['username'],
  );

  await registerFunction(
    sessionId,
    'list_branches',
    listBranches,
    ['username', 'repoName'],
    'Lists branches for a given GitHub repository.',
    {
      username: { type: 'string', description: 'The GitHub username.' },
      repoName: { type: 'string', description: 'The repository name.' },
    },
    ['username', 'repoName'],
  );

  await registerFunction(
    sessionId,
    'list_commit_history',
    listCommitHistory,
    ['username', 'repoName', 'dirName'],
    'Lists commit history for a file in a GitHub repository.',
    {
      username: { type: 'string', description: 'The GitHub username.' },
      repoName: { type: 'string', description: 'The repository name.' },
      dirName: { type: 'string', description: 'The file or directory path.' },
    },
    ['username', 'repoName', 'dirName'],
  );

  await registerFunction(
    sessionId,
    'list_directory_contents',
    listDirectoryContents,
    ['username', 'repoName', 'repoDirName', 'recursive'],
    'Lists the contents of a directory in a GitHub repository.',
    {
      username: { type: 'string', description: 'The GitHub username.' },
      repoName: { type: 'string', description: 'The repository name.' },
      repoDirName: { type: 'string', description: 'The directory path (optional). Defaults to root if not provided' },
      recursive: { type: 'boolean', description: 'Perform a recursive scan or not (optional). Defaults to false if not provided' },
    },
    ['username', 'repoName'],
  );
}

/**
 * Returns the function definitions for the AI tool for a specific session.
 * @param {string} sessionId The unique identifier for the session.
 * @returns {Promise&lt;FunctionMetadata[]>} An array of function metadata.
 */
async function getFunctionDefinitionsForTool(sessionId) {
  return getSessionFuncsMetadata(sessionId);
}

/**
 * Returns the registry of available functions for a specific session.
 * @param {string} sessionId The unique identifier for the session.
 * @returns {Promise&lt;Record&lt;string, RegisteredFunction>>} An object mapping function names to their implementations.
 */
async function getAvailableFunctions(sessionId) {
  return getSessionFunctionRegistry(sessionId);
}

async function loadIntegrations(sessionId) {
  if (process.env.GITHUB_TOKEN) {
    logger.info(`Loading GitHub integration for session: ${sessionId}`);
    await loadGitHub(sessionId);
    logger.info(`Loading GitHub code review integration for session: ${sessionId}`);
    await loadCodeReviews(sessionId);
  }

  if (process.env.DOSA_API_KEY &amp;&amp; process.env.DOSA_API_SECRET
        &amp;&amp; process.env.DOSA_AUTH_TENANT_ID
        &amp;&amp; process.env.DOSA_CLIENT_ID) {
    logger.info(`Loading DOSA/DLVA integration for session: ${sessionId}`);
    await loadDosa(sessionId);
  }
}

async function cleanupSession(sessionId) {
  const release = await registryMutex.acquire();
  try {
    availableFunctionsRegistry.delete(sessionId);
    funcsMetadata.delete(sessionId);
  } finally {
    release();
  }
  await cleanupCodeReviewSession(sessionId); // Clean up resources from codeReviews
  logger.info(`Cleaned up function registry for session: ${sessionId}`);
}

module.exports = {
  getAvailableFunctions,
  getFunctionDefinitionsForTool,
  loadIntegrations,
  cleanupSession,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addResponse">addResponse</a></li><li><a href="global.html#availableFunctionsRegistry">availableFunctionsRegistry</a></li><li><a href="global.html#callFunctionByName">callFunctionByName</a></li><li><a href="global.html#cleanupSession">cleanupSession</a></li><li><a href="global.html#codeReviews">codeReviews</a></li><li><a href="global.html#commitFiles">commitFiles</a></li><li><a href="global.html#createGithubPullRequest">createGithubPullRequest</a></li><li><a href="global.html#createRepo">createRepo</a></li><li><a href="global.html#createUniqueTempDir">createUniqueTempDir</a></li><li><a href="global.html#deleteDirectoryRecursively">deleteDirectoryRecursively</a></li><li><a href="global.html#downloadFile">downloadFile</a></li><li><a href="global.html#downloadMutexes">downloadMutexes</a></li><li><a href="global.html#fetchRepoContentsRecursive">fetchRepoContentsRecursive</a></li><li><a href="global.html#funcsMetadata">funcsMetadata</a></li><li><a href="global.html#getAuthToken">getAuthToken</a></li><li><a href="global.html#getAvailableFunctions">getAvailableFunctions</a></li><li><a href="global.html#getChatResponse">getChatResponse</a></li><li><a href="global.html#getChatSession">getChatSession</a></li><li><a href="global.html#getDownloadMutex">getDownloadMutex</a></li><li><a href="global.html#getFunctionDefinitionsForTool">getFunctionDefinitionsForTool</a></li><li><a href="global.html#getKey">getKey</a></li><li><a href="global.html#getResponse">getResponse</a></li><li><a href="global.html#getSessionFuncsMetadata">getSessionFuncsMetadata</a></li><li><a href="global.html#getSessionFunctionRegistry">getSessionFunctionRegistry</a></li><li><a href="global.html#getSessionMutex">getSessionMutex</a></li><li><a href="global.html#getSessionTokenMutex">getSessionTokenMutex</a></li><li><a href="global.html#getVehicleHistory">getVehicleHistory</a></li><li><a href="global.html#handleFunctionCall">handleFunctionCall</a></li><li><a href="global.html#handleGitHubApiError">handleGitHubApiError</a></li><li><a href="global.html#handleNotFoundError">handleNotFoundError</a></li><li><a href="global.html#listBranches">listBranches</a></li><li><a href="global.html#listCommitHistory">listCommitHistory</a></li><li><a href="global.html#listDirectoryContents">listDirectoryContents</a></li><li><a href="global.html#listGitHubActions">listGitHubActions</a></li><li><a href="global.html#listPublicRepos">listPublicRepos</a></li><li><a href="global.html#mkdir">mkdir</a></li><li><a href="global.html#readContext">readContext</a></li><li><a href="global.html#readFileContent">readFileContent</a></li><li><a href="global.html#readFilesInDirectory">readFilesInDirectory</a></li><li><a href="global.html#readFilesRecursively">readFilesRecursively</a></li><li><a href="global.html#registerFunction">registerFunction</a></li><li><a href="global.html#registryMutex">registryMutex</a></li><li><a href="global.html#sessionAuthTokens">sessionAuthTokens</a></li><li><a href="global.html#sessionTokenExpiries">sessionTokenExpiries</a></li><li><a href="global.html#sessionTokenMutexes">sessionTokenMutexes</a></li><li><a href="global.html#sessions">sessions</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri May 02 2025 19:44:57 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
