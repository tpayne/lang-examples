<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: chatbot.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: chatbot.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const RateLimit = require('express-rate-limit');
const bodyParser = require('body-parser');
const dotenv = require('dotenv');
const express = require('express');
const fs = require('fs').promises;
const logger = require('./logger');
const morganMiddleware = require('./morganmw');
const path = require('path');
const session = require('express-session');
const util = require('util');
const { GoogleGenerativeAI } = require("@google/generative-ai");
const { getAvailableFunctions, getFunctionDefinitionsForTool, loadIntegrations } = require('./functions');
const { getConfig, loadProperties } = require('./properties');

dotenv.config();

const app = express();

// Rate limiting (as before)
const limiter = RateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100,
    keyGenerator: (req) => req.sessionID, // Use session ID for rate limiting
});
app.use(limiter);

const ai = new GoogleGenerativeAI({ apiKey: process.env.GOOGLE_API_KEY });

/**
 * Stores the conversation history and context for each client session.
 * The key is the client's session ID.
 * @type {Map&lt;string, { context: string, chat: import('@google/generative-ai').ChatSession | null, history: Array&lt;import('@google/generative-ai').Part[]> }>}
 */
const sessions = new Map();

const MemcachedStore = require('connect-memcached')(session);

app.use(session({
    secret: process.env.GOOGLE_API_KEY,
    resave: false,
    saveUninitialized: true,
    store: new MemcachedStore({
        hosts: ['127.0.0.1:11211']
    })
}));

app.use(bodyParser.json());
app.use(morganMiddleware);

const getKey = (keyString) => keyString.replace(/\W+/g, '').toUpperCase();

const addResponse = (sessionId, query, response) => {
    if (!sessions.has(sessionId)) {
        sessions.set(sessionId, { context: '', chat: null, history: [], messageCache: new Map() });
    }
    const session = sessions.get(sessionId);
    const cache = session.messageCache;
    const keyStr = getKey(query);
    if (cache.has(keyStr)) return true;
    if (cache.size > 1000) {
        Array.from(cache.keys()).slice(0, 100).forEach((key) => cache.delete(key));
    }
    cache.set(keyStr, response);
    return true;
};

const getResponse = (sessionId, query) => {
    const session = sessions.get(sessionId);
    return session?.messageCache?.get(getKey(query)) || '';
};

const readContext = async (contextStr) => {
    try {
        const contextPath = path.resolve('contexts', contextStr);
        const normalizedContextPath = path.normalize(contextPath);
        const normalizedContextsPath = path.normalize(path.resolve('contexts'));
        if (!normalizedContextPath.startsWith(normalizedContextsPath)) {
            throw new Error('Invalid context path');
        }
        return await fs.readFile(contextPath, 'utf-8');
    } catch (err) {
        logger.error(`Cannot load context '${contextStr}'`, err);
        return '';
    }
};

const callFunctionByName = async (name, args) => {
    const functionInfo = getAvailableFunctions()[name];
    if (functionInfo &amp;&amp; functionInfo.func) {
        const { func, params } = functionInfo;
        const argValues = params.map((paramName) => args[paramName]);
        try {
            const result = await func.apply(null, argValues);
            logger.info(`Function '${name}' executed`, { arguments: args, result });
            return result;
        } catch (error) {
            logger.error(`Error executing function '${name}'`, { arguments: args, error: error.message });
            return { error: 'Function execution failed', details: error.message };
        }
    }
    return { error: `Function '${name}' not found` };
};

const handleFunctionCall = async (functionCall) => {
    const { name, args } = functionCall;
    return await callFunctionByName(name, args);
};

/**
 * Gets or creates a chat session for a given client, initializing with history.
 * @param {string} sessionId The ID of the client session.
 * @returns {import('@google/generative-ai').ChatSession} The chat session.
 */
const getChatSession = (sessionId) => {
    if (!sessions.has(sessionId)) {
        sessions.set(sessionId, { context: '', chat: null, history: [], messageCache: new Map() });
    }
    const session = sessions.get(sessionId);
    if (!session.chat) {
        const model = ai.generativeModel({ model: getConfig().aiModel });
        session.chat = model.startChat({
            history: session.history, // Initialize with stored history
            generationConfig: {
                maxOutputTokens: Number(getConfig().maxTokens),
                temperature: Number(getConfig().temperature),
                topP: Number(getConfig().top_p),
            },
        });
    }
    return session.chat;
};

/**
 * Gets a chat response from the Gemini API, maintaining state per session.
 * @param {string} sessionId The ID of the client session.
 * @param {string} userInput The user's message.
 * @param {boolean} [forceJson=false] Whether to request a JSON response.
 * @returns {Promise&lt;string|object>} The chatbot's response.
 */
const getChatResponse = async (sessionId, userInput, forceJson = false) => {
    await loadIntegrations(sessionId);
    const tools = getFunctionDefinitionsForTool();
    let session = sessions.get(sessionId); // Retrieve the session

    // Initialize the session if it doesn't exist
    if (!session) {
        session = { context: '', chat: null, history: [], messageCache: new Map() };
        sessions.set(sessionId, session); // Set the newly created session
    }

    // Handle special commands per session
    if (userInput.includes('help')) return 'Sample *Help* text';
    if (userInput.includes('bot-echo-string')) {
        return userInput || 'No string to echo';
    }
    if (userInput.includes('bot-context')) {
        const botCmd = userInput.split(' ');
        switch (botCmd[1]) {
            case 'load':
                session.context = await readContext(botCmd[2].trim()); // Now session is guaranteed to be defined
                return session.context ? 'Context loaded for this session' : 'Context file could not be read or is empty';
            case 'show':
                return session.context || 'Context is empty for this session';
            case 'reset':
                session.context = '';
                // Reset logic...
                return 'Context and chat history reset for this session';
            default:
                return 'Invalid command';
        }
    }

    if (!session.context) return 'Error: Context is not set for this session. Please load one.';

    const cachedResponse = getResponse(sessionId, userInput);
    if (cachedResponse) return cachedResponse;

    try {
        const chat = getChatSession(sessionId);
        let prompt = `${session.context}\n${userInput}`;
        if (forceJson) {
            prompt += '\nYour response must be in JSON format.';
        }

        const functionDefs = tools.map((tool) => tool.function);
        const toolConfig = tools.length > 0 ? { tools: [{ functionDeclarations: functionDefs }] } : {};

        let finalResponse = null;
        let functionCallResult = null;
        let numFunctionCalls = 0;
        const maxFunctionCalls = 5;
        let currentTurnParts = [{ text: prompt }];

        while (!finalResponse &amp;&amp; numFunctionCalls &lt; maxFunctionCalls) {
            const result = await chat.sendMessage({
                parts: currentTurnParts,
                ...toolConfig,
            });
            const response = await result.response;

            if (response.candidates &amp;&amp; response.candidates.length > 0) {
                const candidate = response.candidates[0];
                if (candidate.content &amp;&amp; candidate.content.parts &amp;&amp; candidate.content.parts.length > 0) {
                    const part = candidate.content.parts[0];
                    session.history.push(currentTurnParts); // Store user's turn

                    if (part.functionCall) {
                        numFunctionCalls++;
                        const functionName = part.functionCall.name;
                        const functionArgs = part.functionCall.args;
                        logger.info(`Tool call initiated [Session: ${sessionId}], ${functionName} => ${JSON.stringify(functionArgs)}`);
                        functionCallResult = await handleFunctionCall(part.functionCall);
                        logger.info(`Tool call result [Session: ${sessionId}], ${functionName} => ${util.inspect(functionCallResult)}`);

                        const functionResponsePart = {
                            functionResponse: {
                                name: functionName,
                                response: { functionCallResult },
                            },
                        };
                        session.history.push([functionResponsePart]); // Store function response turn
                        await chat.sendMessage({ parts: [functionResponsePart] });
                    } else if (part.text) {
                        finalResponse = part.text;
                        session.history.push([{ text: finalResponse }]); // Store bot's final response
                    }
                }
            } else {
                logger.warn(`Gemini API: No candidates in response [Session: ${sessionId}]`);
                break;
            }

            if (numFunctionCalls >= maxFunctionCalls &amp;&amp; !finalResponse) {
                finalResponse = 'Error: Maximum function call limit reached without a final response.';
            }
            currentTurnParts = []; // Clear for the next potential turn in the loop
        }

        if (!finalResponse &amp;&amp; functionCallResult !== null &amp;&amp; typeof functionCallResult !== 'object' &amp;&amp; !functionCallResult.error) {
            finalResponse = functionCallResult;
            session.history.push([{ text: finalResponse }]);
        } else if (!finalResponse &amp;&amp; functionCallResult &amp;&amp; functionCallResult.error) {
            finalResponse = `Function call failed: ${functionCallResult.error} - ${functionCallResult.details || ''}`;
            session.history.push([{ text: finalResponse }]);
        }

        if (!finalResponse) {
            throw Error('Not able to get a final response from Gemini.');
        }

        addResponse(sessionId, userInput, finalResponse);
        return finalResponse;

    } catch (err) {
        logger.error(`Gemini API error [Session: ${sessionId}]:`, err);
        return `Error processing request - ${err}`;
    }
};

app.get('/', (req, res) => res.sendFile(path.join(__dirname, 'templates/indexBot.html')));
app.get('/version', (req, res) => res.json({ version: '1.0' }));
app.get('/status', (req, res) => res.json({ status: 'live' }));

app.post('/chat', async (req, res) => {
    const userMessage = req.body.message;
    const sessionId = req.sessionID;
    logger.info(`Chat request received [Session: ${sessionId}]`, { message: userMessage });
    const resp = await getChatResponse(sessionId, userMessage);
    res.json({ response: (resp) || 'Error: no response was detected' });
});

process.on('SIGINT', () => process.exit(0));
process.on('SIGILL', () => process.exit(1));
process.on('SIGSEG', () => process.exit(1));
process.on('SIGBUS', () => process.exit(1));

const startServer = () => {
    if (loadProperties('resources/app.properties')) {
        const port = Number(getConfig().port) || 5000;
        app.listen(port, '0.0.0.0', () => logger.info(`Listening on port ${port}`));
    } else {
        process.exit(1);
    }
};

startServer();</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#availableFunctionsRegistry">availableFunctionsRegistry</a></li><li><a href="global.html#cleanupSession">cleanupSession</a></li><li><a href="global.html#codeReviews">codeReviews</a></li><li><a href="global.html#createGithubPullRequest">createGithubPullRequest</a></li><li><a href="global.html#createUniqueTempDir">createUniqueTempDir</a></li><li><a href="global.html#deleteDirectoryRecursively">deleteDirectoryRecursively</a></li><li><a href="global.html#downloadFile">downloadFile</a></li><li><a href="global.html#downloadMutexes">downloadMutexes</a></li><li><a href="global.html#fetchRepoContentsRecursive">fetchRepoContentsRecursive</a></li><li><a href="global.html#funcsMetadata">funcsMetadata</a></li><li><a href="global.html#getAuthToken">getAuthToken</a></li><li><a href="global.html#getAvailableFunctions">getAvailableFunctions</a></li><li><a href="global.html#getChatResponse">getChatResponse</a></li><li><a href="global.html#getChatSession">getChatSession</a></li><li><a href="global.html#getDownloadMutex">getDownloadMutex</a></li><li><a href="global.html#getFunctionDefinitionsForTool">getFunctionDefinitionsForTool</a></li><li><a href="global.html#getSessionFuncsMetadata">getSessionFuncsMetadata</a></li><li><a href="global.html#getSessionFunctionRegistry">getSessionFunctionRegistry</a></li><li><a href="global.html#getSessionMutex">getSessionMutex</a></li><li><a href="global.html#getSessionTokenMutex">getSessionTokenMutex</a></li><li><a href="global.html#getVehicleHistory">getVehicleHistory</a></li><li><a href="global.html#handleGitHubApiError">handleGitHubApiError</a></li><li><a href="global.html#handleNotFoundError">handleNotFoundError</a></li><li><a href="global.html#listBranches">listBranches</a></li><li><a href="global.html#listCommitHistory">listCommitHistory</a></li><li><a href="global.html#listDirectoryContents">listDirectoryContents</a></li><li><a href="global.html#listGitHubActions">listGitHubActions</a></li><li><a href="global.html#listPublicRepos">listPublicRepos</a></li><li><a href="global.html#mkdir">mkdir</a></li><li><a href="global.html#readFileContent">readFileContent</a></li><li><a href="global.html#readFilesInDirectory">readFilesInDirectory</a></li><li><a href="global.html#readFilesRecursively">readFilesRecursively</a></li><li><a href="global.html#registerFunction">registerFunction</a></li><li><a href="global.html#registryMutex">registryMutex</a></li><li><a href="global.html#sessionAuthTokens">sessionAuthTokens</a></li><li><a href="global.html#sessionTokenExpiries">sessionTokenExpiries</a></li><li><a href="global.html#sessionTokenMutexes">sessionTokenMutexes</a></li><li><a href="global.html#sessions">sessions</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Apr 18 2025 15:06:22 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
